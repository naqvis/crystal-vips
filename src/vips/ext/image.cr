# This file was automatically generated by running:
#
#   scripts/gen_ext.cr
#
# libvips version: 8.12.2
#
# DO NOT EDIT
#
# Changes to this file may cause incorrect behavior and will be lost if the code is regenerated
#

module Vips
  class Image
    # Absolute value of an image
    #
    # ```
    # # out_ = in.abs()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def abs
      self.call("abs").as(Type).as_image
    end

    # Add two images
    #
    # ```
    # # out_ = left.add(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    #
    # **Returns**
    #
    # Output image
    #
    def add(right : Image)
      self.call("add", right).as(Type).as_image
    end

    # Affine transform of an image
    #
    # ```
    # # out_ = in.affine(matrix, {interpolate: Interpolate, oarea: Array(Int32), odx: Float64, ody: Float64, idx: Float64, idy: Float64, background: Array(Float64), premultiplied: Bool, extend: Enums::Extend})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *matrix* : Array(Float64) - Transformation matrix
    #
    # _Optionals_
    #
    # *interpolate* : Interpolate - Interpolate pixels with this
    #
    # *oarea* : Array(Int32) - Area of output to generate
    #
    # *odx* : Float64 - Horizontal output displacement
    #
    # *ody* : Float64 - Vertical output displacement
    #
    # *idx* : Float64 - Horizontal input displacement
    #
    # *idy* : Float64 - Vertical input displacement
    #
    # *background* : Array(Float64) - Background value
    #
    # *premultiplied* : Bool - Images have premultiplied alpha
    #
    # *extend* : Enums::Extend - How to generate the extra pixels
    #
    #
    # **Returns**
    #
    # Output image
    #
    def affine(matrix : Array(Float64), **kwargs)
      options = Optional.new(**kwargs)

      self.call("affine", options, matrix).as(Type).as_image
    end

    # Load an analyze6 image
    #
    # ```
    # # out_, flags = Vips::Image.analyzeload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.analyzeload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("analyzeload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Join an array of images
    #
    # ```
    # # out_ = Vips::Image.arrayjoin(in_, {across: Int32, shim: Int32, background: Array(Float64), halign: Enums::Align, valign: Enums::Align, hspacing: Int32, vspacing: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *in* : Array(Image) - Array of input images
    #
    # _Optionals_
    #
    # *across* : Int32 - Number of images across grid
    #
    # *shim* : Int32 - Pixels between images
    #
    # *background* : Array(Float64) - Colour for new pixels
    #
    # *halign* : Enums::Align - Align on the left, centre or right
    #
    # *valign* : Enums::Align - Align on the top, centre or bottom
    #
    # *hspacing* : Int32 - Horizontal spacing between images
    #
    # *vspacing* : Int32 - Vertical spacing between images
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.arrayjoin(in_ : Array(Image), **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("arrayjoin", options, in_).as(Type).as_image
    end

    # Autorotate image by exif tag
    #
    # ```
    # # out_, angle, flip = in.autorot()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *angle* : Enums::Angle? - Angle image was rotated by
    #
    # *flip* : Bool? - Whether the image was flipped or not
    #
    def autorot
      optional_output = Optional.new(**{angle: true, flip: true})

      results = self.call("autorot", optional_output).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      angle = ((o = opts) && (val = o["angle"]?)) ? val.as_enum(Enums::Angle) : nil
      flip = ((o = opts) && (val = o["flip"]?)) ? val.as_b : nil
      {final_result, angle, flip}
    end

    # Find image average
    #
    # ```
    # # out_ = in.avg()
    # ```
    #
    #
    # **Returns**
    #
    # Output value
    #
    def avg
      self.call("avg").as(Type).as_f64
    end

    # Save image in avif format
    #
    # ```
    # in.avifsave_target(target, {q: Int32, lossless: Bool, compression: Enums::ForeignHeifCompression, effort: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *compression* : Enums::ForeignHeifCompression - Compression format
    #
    # *effort* : Int32 - CPU effort
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def avifsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("avifsave_target", options, target)
    end

    # Save image in avif format
    #
    # ```
    # in.avifsave_stream(stream, {q: Int32, lossless: Bool, compression: Enums::ForeignHeifCompression, effort: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *compression* : Enums::ForeignHeifCompression - Compression format
    #
    # *effort* : Int32 - CPU effort
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def avifsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      avifsave_target(target, **kwargs)
    end

    # Boolean operation across image bands
    #
    # ```
    # # out_ = in.bandbool(boolean)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *boolean* : Enums::OperationBoolean - boolean to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def bandbool(boolean : Enums::OperationBoolean)
      self.call("bandbool", boolean).as(Type).as_image
    end

    # Fold up x axis into bands
    #
    # ```
    # # out_ = in.bandfold({factor: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *factor* : Int32 - Fold by this factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def bandfold(**kwargs)
      options = Optional.new(**kwargs)

      self.call("bandfold", options).as(Type).as_image
    end

    # Append a constant band to an image
    #
    # ```
    # # out_ = in.bandjoin_const(c)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *c* : Array(Float64) - Array of constants to add
    #
    #
    # **Returns**
    #
    # Output image
    #
    def bandjoin_const(c : Array(Float64))
      self.call("bandjoin_const", c).as(Type).as_image
    end

    # Band-wise average
    #
    # ```
    # # out_ = in.bandmean()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def bandmean
      self.call("bandmean").as(Type).as_image
    end

    # Unfold image bands into x axis
    #
    # ```
    # # out_ = in.bandunfold({factor: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *factor* : Int32 - Unfold by this factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def bandunfold(**kwargs)
      options = Optional.new(**kwargs)

      self.call("bandunfold", options).as(Type).as_image
    end

    # Make a black image
    #
    # ```
    # # out_ = Vips::Image.black(width, height, {bands: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *bands* : Int32 - Number of bands in image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.black(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("black", options, width, height).as(Type).as_image
    end

    # Boolean operation on two images
    #
    # ```
    # # out_ = left.boolean(right, boolean)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    # *boolean* : Enums::OperationBoolean - boolean to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def boolean(right : Image, boolean : Enums::OperationBoolean)
      self.call("boolean", right, boolean).as(Type).as_image
    end

    # Boolean operations against a constant
    #
    # ```
    # # out_ = in.boolean_const(boolean, c)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *boolean* : Enums::OperationBoolean - boolean to perform
    #
    # *c* : Array(Float64) - Array of constants
    #
    #
    # **Returns**
    #
    # Output image
    #
    def boolean_const(boolean : Enums::OperationBoolean, c : Array(Float64))
      self.call("boolean_const", boolean, c).as(Type).as_image
    end

    # Build a look-up table
    #
    # ```
    # # out_ = in.buildlut()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def buildlut
      self.call("buildlut").as(Type).as_image
    end

    # Byteswap an image
    #
    # ```
    # # out_ = in.byteswap()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def byteswap
      self.call("byteswap").as(Type).as_image
    end

    # Cache an image
    #
    # ```
    # # out_ = in.cache({max_tiles: Int32, tile_height: Int32, tile_width: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *max_tiles* : Int32 - Maximum number of tiles to cache
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    #
    # **Returns**
    #
    # Output image
    #
    def cache(**kwargs)
      options = Optional.new(**kwargs)

      self.call("cache", options).as(Type).as_image
    end

    # Canny edge detector
    #
    # ```
    # # out_ = in.canny({sigma: Float64, precision: Enums::Precision})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *sigma* : Float64 - Sigma of Gaussian
    #
    # *precision* : Enums::Precision - Convolve with this precision
    #
    #
    # **Returns**
    #
    # Output image
    #
    def canny(**kwargs)
      options = Optional.new(**kwargs)

      self.call("canny", options).as(Type).as_image
    end

    # Cast an image
    #
    # ```
    # # out_ = in.cast(format, {shift: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *format* : Enums::BandFormat - Format to cast to
    #
    # _Optionals_
    #
    # *shift* : Bool - Shift integer values up and down
    #
    #
    # **Returns**
    #
    # Output image
    #
    def cast(format : Enums::BandFormat, **kwargs)
      options = Optional.new(**kwargs)

      self.call("cast", options, format).as(Type).as_image
    end

    # Transform lch to cmc
    #
    # ```
    # # out_ = in.cmc2lch()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def cmc2lch
      self.call("cmc2lch").as(Type).as_image
    end

    # Transform cmyk to xyz
    #
    # ```
    # # out_ = in.cmyk2xyz()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def cmyk2xyz
      self.call("cmyk2xyz").as(Type).as_image
    end

    # Convert to a new colorspace
    #
    # ```
    # # out_ = in.colourspace(space, {source_space: Enums::Interpretation})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *space* : Enums::Interpretation - Destination color space
    #
    # _Optionals_
    #
    # *source_space* : Enums::Interpretation - Source color space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def colourspace(space : Enums::Interpretation, **kwargs)
      options = Optional.new(**kwargs)

      self.call("colourspace", options, space).as(Type).as_image
    end

    # Convolve with rotating mask
    #
    # ```
    # # out_ = in.compass(mask, {times: Int32, angle: Enums::Angle45, combine: Enums::Combine, precision: Enums::Precision, layers: Int32, cluster: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    # _Optionals_
    #
    # *times* : Int32 - Rotate and convolve this many times
    #
    # *angle* : Enums::Angle45 - Rotate mask by this much between convolutions
    #
    # *combine* : Enums::Combine - Combine convolution results like this
    #
    # *precision* : Enums::Precision - Convolve with this precision
    #
    # *layers* : Int32 - Use this many layers in approximation
    #
    # *cluster* : Int32 - Cluster lines closer than this in approximation
    #
    #
    # **Returns**
    #
    # Output image
    #
    def compass(mask : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("compass", options, mask).as(Type).as_image
    end

    # Perform a complex operation on an image
    #
    # ```
    # # out_ = in.complex(cmplx)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *cmplx* : Enums::OperationComplex - complex to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def complex(cmplx : Enums::OperationComplex)
      self.call("complex", cmplx).as(Type).as_image
    end

    # Complex binary operations on two images
    #
    # ```
    # # out_ = left.complex2(right, cmplx)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    # *cmplx* : Enums::OperationComplex2 - binary complex operation to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def complex2(right : Image, cmplx : Enums::OperationComplex2)
      self.call("complex2", right, cmplx).as(Type).as_image
    end

    # Form a complex image from two real images
    #
    # ```
    # # out_ = left.complexform(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    #
    # **Returns**
    #
    # Output image
    #
    def complexform(right : Image)
      self.call("complexform", right).as(Type).as_image
    end

    # Get a component from a complex image
    #
    # ```
    # # out_ = in.complexget(get)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *get* : Enums::OperationComplexget - complex to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def complexget(get : Enums::OperationComplexget)
      self.call("complexget", get).as(Type).as_image
    end

    # Blend a pair of images with a blend mode
    #
    # ```
    # # out_ = base.composite2(overlay, mode, {x: Int32, y: Int32, compositing_space: Enums::Interpretation, premultiplied: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *overlay* : Image - Overlay image
    #
    # *mode* : Enums::BlendMode - VipsBlendMode to join with
    #
    # _Optionals_
    #
    # *x* : Int32 - x position of overlay
    #
    # *y* : Int32 - y position of overlay
    #
    # *compositing_space* : Enums::Interpretation - Composite images in this colour space
    #
    # *premultiplied* : Bool - Images have premultiplied alpha
    #
    #
    # **Returns**
    #
    # Output image
    #
    def composite2(overlay : Image, mode : Enums::BlendMode, **kwargs)
      options = Optional.new(**kwargs)

      self.call("composite2", options, overlay, mode).as(Type).as_image
    end

    # Convolution operation
    #
    # ```
    # # out_ = in.conv(mask, {precision: Enums::Precision, layers: Int32, cluster: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    # _Optionals_
    #
    # *precision* : Enums::Precision - Convolve with this precision
    #
    # *layers* : Int32 - Use this many layers in approximation
    #
    # *cluster* : Int32 - Cluster lines closer than this in approximation
    #
    #
    # **Returns**
    #
    # Output image
    #
    def conv(mask : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("conv", options, mask).as(Type).as_image
    end

    # Approximate integer convolution
    #
    # ```
    # # out_ = in.conva(mask, {layers: Int32, cluster: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    # _Optionals_
    #
    # *layers* : Int32 - Use this many layers in approximation
    #
    # *cluster* : Int32 - Cluster lines closer than this in approximation
    #
    #
    # **Returns**
    #
    # Output image
    #
    def conva(mask : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("conva", options, mask).as(Type).as_image
    end

    # Approximate separable integer convolution
    #
    # ```
    # # out_ = in.convasep(mask, {layers: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    # _Optionals_
    #
    # *layers* : Int32 - Use this many layers in approximation
    #
    #
    # **Returns**
    #
    # Output image
    #
    def convasep(mask : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("convasep", options, mask).as(Type).as_image
    end

    # Float convolution operation
    #
    # ```
    # # out_ = in.convf(mask)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def convf(mask : Image)
      self.call("convf", mask).as(Type).as_image
    end

    # Int convolution operation
    #
    # ```
    # # out_ = in.convi(mask)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def convi(mask : Image)
      self.call("convi", mask).as(Type).as_image
    end

    # Seperable convolution operation
    #
    # ```
    # # out_ = in.convsep(mask, {precision: Enums::Precision, layers: Int32, cluster: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    # _Optionals_
    #
    # *precision* : Enums::Precision - Convolve with this precision
    #
    # *layers* : Int32 - Use this many layers in approximation
    #
    # *cluster* : Int32 - Cluster lines closer than this in approximation
    #
    #
    # **Returns**
    #
    # Output image
    #
    def convsep(mask : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("convsep", options, mask).as(Type).as_image
    end

    # Copy an image
    #
    # ```
    # # out_ = in.copy({width: Int32, height: Int32, bands: Int32, format: Enums::BandFormat, coding: Enums::Coding, interpretation: Enums::Interpretation, xres: Float64, yres: Float64, xoffset: Int32, yoffset: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *bands* : Int32 - Number of bands in image
    #
    # *format* : Enums::BandFormat - Pixel format in image
    #
    # *coding* : Enums::Coding - Pixel coding
    #
    # *interpretation* : Enums::Interpretation - Pixel interpretation
    #
    # *xres* : Float64 - Horizontal resolution in pixels/mm
    #
    # *yres* : Float64 - Vertical resolution in pixels/mm
    #
    # *xoffset* : Int32 - Horizontal offset of origin
    #
    # *yoffset* : Int32 - Vertical offset of origin
    #
    #
    # **Returns**
    #
    # Output image
    #
    def copy(**kwargs)
      options = Optional.new(**kwargs)

      self.call("copy", options).as(Type).as_image
    end

    # Count lines in an image
    #
    # ```
    # # nolines = in.countlines(direction)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *direction* : Enums::Direction - Countlines left-right or up-down
    #
    #
    # **Returns**
    #
    # Number of lines
    #
    def countlines(direction : Enums::Direction)
      self.call("countlines", direction).as(Type).as_f64
    end

    # Load csv
    #
    # ```
    # # out_, flags = Vips::Image.csvload(filename, {skip: Int32, lines: Int32, whitespace: String, separator: String, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *skip* : Int32 - Skip this many lines at the start of the file
    #
    # *lines* : Int32 - Read this many lines from the file
    #
    # *whitespace* : String - Set of whitespace characters
    #
    # *separator* : String - Set of separator characters
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.csvload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("csvload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load csv
    #
    # ```
    # # out_, flags = Vips::Image.csvload_source(source, {skip: Int32, lines: Int32, whitespace: String, separator: String, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *skip* : Int32 - Skip this many lines at the start of the file
    #
    # *lines* : Int32 - Read this many lines from the file
    #
    # *whitespace* : String - Set of whitespace characters
    #
    # *separator* : String - Set of separator characters
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.csvload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("csvload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load csv
    #
    # ```
    # # out_, flags = Vips::Image.csvload_stream(stream, {skip: Int32, lines: Int32, whitespace: String, separator: String, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *skip* : Int32 - Skip this many lines at the start of the file
    #
    # *lines* : Int32 - Read this many lines from the file
    #
    # *whitespace* : String - Set of whitespace characters
    #
    # *separator* : String - Set of separator characters
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.csvload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      csvload_source(source, **kwargs)
    end

    # Save image to csv
    #
    # ```
    # in.csvsave(filename, {separator: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *separator* : String - Separator characters
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def csvsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("csvsave", options, filename)
    end

    # Save image to csv
    #
    # ```
    # in.csvsave_target(target, {separator: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *separator* : String - Separator characters
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def csvsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("csvsave_target", options, target)
    end

    # Save image to csv
    #
    # ```
    # in.csvsave_stream(stream, {separator: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *separator* : String - Separator characters
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def csvsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      csvsave_target(target, **kwargs)
    end

    # Calculate de00
    #
    # ```
    # # out_ = left.de00(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand input image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def de00(right : Image)
      self.call("de00", right).as(Type).as_image
    end

    # Calculate de76
    #
    # ```
    # # out_ = left.de76(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand input image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def de76(right : Image)
      self.call("de76", right).as(Type).as_image
    end

    # Calculate decmc
    #
    # ```
    # # out_ = left.decmc(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand input image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def decmc(right : Image)
      self.call("decmc", right).as(Type).as_image
    end

    # Find image standard deviation
    #
    # ```
    # # out_ = in.deviate()
    # ```
    #
    #
    # **Returns**
    #
    # Output value
    #
    def deviate
      self.call("deviate").as(Type).as_f64
    end

    # Divide two images
    #
    # ```
    # # out_ = left.divide(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    #
    # **Returns**
    #
    # Output image
    #
    def divide(right : Image)
      self.call("divide", right).as(Type).as_image
    end

    # Save image to deepzoom file
    #
    # ```
    # in.dzsave(filename, {basename: String, layout: Enums::ForeignDzLayout, suffix: String, overlap: Int32, tile_size: Int32, centre: Bool, depth: Enums::ForeignDzDepth, angle: Enums::Angle, container: Enums::ForeignDzContainer, properties: Bool, compression: Int32, region_shrink: Enums::RegionShrink, skip_blanks: Int32, no_strip: Bool, id: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *basename* : String - Base name to save to
    #
    # *layout* : Enums::ForeignDzLayout - Directory layout
    #
    # *suffix* : String - Filename suffix for tiles
    #
    # *overlap* : Int32 - Tile overlap in pixels
    #
    # *tile_size* : Int32 - Tile size in pixels
    #
    # *centre* : Bool - Center image in tile
    #
    # *depth* : Enums::ForeignDzDepth - Pyramid depth
    #
    # *angle* : Enums::Angle - Rotate image during save
    #
    # *container* : Enums::ForeignDzContainer - Pyramid container type
    #
    # *properties* : Bool - Write a properties file to the output directory
    #
    # *compression* : Int32 - ZIP deflate compression level
    #
    # *region_shrink* : Enums::RegionShrink - Method to shrink regions
    #
    # *skip_blanks* : Int32 - Skip tiles which are nearly equal to the background
    #
    # *no_strip* : Bool - Don't strip tile metadata
    #
    # *id* : String - Resource ID
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def dzsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("dzsave", options, filename)
    end

    # Save image to dz buffer
    #
    # ```
    # # buffer = in.dzsave_buffer({basename: String, layout: Enums::ForeignDzLayout, suffix: String, overlap: Int32, tile_size: Int32, centre: Bool, depth: Enums::ForeignDzDepth, angle: Enums::Angle, container: Enums::ForeignDzContainer, properties: Bool, compression: Int32, region_shrink: Enums::RegionShrink, skip_blanks: Int32, no_strip: Bool, id: String, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *basename* : String - Base name to save to
    #
    # *layout* : Enums::ForeignDzLayout - Directory layout
    #
    # *suffix* : String - Filename suffix for tiles
    #
    # *overlap* : Int32 - Tile overlap in pixels
    #
    # *tile_size* : Int32 - Tile size in pixels
    #
    # *centre* : Bool - Center image in tile
    #
    # *depth* : Enums::ForeignDzDepth - Pyramid depth
    #
    # *angle* : Enums::Angle - Rotate image during save
    #
    # *container* : Enums::ForeignDzContainer - Pyramid container type
    #
    # *properties* : Bool - Write a properties file to the output directory
    #
    # *compression* : Int32 - ZIP deflate compression level
    #
    # *region_shrink* : Enums::RegionShrink - Method to shrink regions
    #
    # *skip_blanks* : Int32 - Skip tiles which are nearly equal to the background
    #
    # *no_strip* : Bool - Don't strip tile metadata
    #
    # *id* : String - Resource ID
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def dzsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("dzsave_buffer", options).as(Type).as_bytes
    end

    # Embed an image in a larger image
    #
    # ```
    # # out_ = in.embed(x, y, width, height, {extend: Enums::Extend, background: Array(Float64)})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *x* : Int32 - Left edge of input in output
    #
    # *y* : Int32 - Top edge of input in output
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *extend* : Enums::Extend - How to generate the extra pixels
    #
    # *background* : Array(Float64) - Color for background pixels
    #
    #
    # **Returns**
    #
    # Output image
    #
    def embed(x : Int32, y : Int32, width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("embed", options, x, y, width, height).as(Type).as_image
    end

    # Extract an area from an image
    #
    # ```
    # # out_ = input.extract_area(left, top, width, height)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *left* : Int32 - Left edge of extract area
    #
    # *top* : Int32 - Top edge of extract area
    #
    # *width* : Int32 - Width of extract area
    #
    # *height* : Int32 - Height of extract area
    #
    #
    # **Returns**
    #
    # Output image
    #
    def extract_area(left : Int32, top : Int32, width : Int32, height : Int32)
      self.call("extract_area", left, top, width, height).as(Type).as_image
    end

    # Extract band from an image
    #
    # ```
    # # out_ = in.extract_band(band, {n: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *band* : Int32 - Band to extract
    #
    # _Optionals_
    #
    # *n* : Int32 - Number of bands to extract
    #
    #
    # **Returns**
    #
    # Output image
    #
    def extract_band(band : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("extract_band", options, band).as(Type).as_image
    end

    # Make an image showing the eye's spatial response
    #
    # ```
    # # out_ = Vips::Image.eye(width, height, {uchar: Bool, factor: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *factor* : Float64 - Maximum spatial frequency
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.eye(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("eye", options, width, height).as(Type).as_image
    end

    # False-color an image
    #
    # ```
    # # out_ = in.falsecolour()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def falsecolour
      self.call("falsecolour").as(Type).as_image
    end

    # Fast correlation
    #
    # ```
    # # out_ = in.fastcor(ref)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *ref* : Image - Input reference image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def fastcor(ref : Image)
      self.call("fastcor", ref).as(Type).as_image
    end

    # Fill image zeros with nearest non-zero pixel
    #
    # ```
    # # out_, distance = in.fill_nearest()
    # ```
    #
    #
    # **Returns**
    #
    # Value of nearest non-zero pixel
    #
    # _Optionals_
    #
    # *distance* : Image? - Distance to nearest non-zero pixel
    #
    def fill_nearest
      optional_output = Optional.new(**{distance: true})

      results = self.call("fill_nearest", optional_output).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      distance = ((o = opts) && (val = o["distance"]?)) ? val.as_image : nil
      {final_result, distance}
    end

    # Search an image for non-edge areas
    #
    # ```
    # # output   = in.find_trim({threshold: Float64, background: Array(Float64)})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *threshold* : Float64 - Object threshold
    #
    # *background* : Array(Float64) - Color for background pixels
    #
    #
    # **Returns**
    #
    # Left edge of image
    #
    # Top edge of extract area
    #
    # Width of extract area
    #
    # Height of extract area
    #
    def find_trim(**kwargs)
      options = Optional.new(**kwargs)

      results = self.call("find_trim", options).as(Array(Type))

      {results[0].as_i32, results[1].as_i32, results[2].as_i32, results[3].as_i32}
    end

    # Load a fits image
    #
    # ```
    # # out_, flags = Vips::Image.fitsload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.fitsload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("fitsload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load fits from a source
    #
    # ```
    # # out_, flags = Vips::Image.fitsload_source(source, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.fitsload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("fitsload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load fits from a stream
    #
    # ```
    # # out_, flags = Vips::Image.fitsload_stream(stream, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.fitsload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      fitsload_source(source, **kwargs)
    end

    # Save image to fits file
    #
    # ```
    # in.fitssave(filename, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def fitssave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("fitssave", options, filename)
    end

    # Flatten alpha out of an image
    #
    # ```
    # # out_ = in.flatten({background: Array(Float64), max_alpha: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *background* : Array(Float64) - Background value
    #
    # *max_alpha* : Float64 - Maximum value of alpha channel
    #
    #
    # **Returns**
    #
    # Output image
    #
    def flatten(**kwargs)
      options = Optional.new(**kwargs)

      self.call("flatten", options).as(Type).as_image
    end

    # Flip an image
    #
    # ```
    # # out_ = in.flip(direction)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *direction* : Enums::Direction - Direction to flip image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def flip(direction : Enums::Direction)
      self.call("flip", direction).as(Type).as_image
    end

    # Transform float rgb to radiance coding
    #
    # ```
    # # out_ = in.float2rad()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def float2rad
      self.call("float2rad").as(Type).as_image
    end

    # Make a fractal surface
    #
    # ```
    # # out_ = Vips::Image.fractsurf(width, height, fractal_dimension)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *fractal_dimension* : Float64 - Fractal dimension
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.fractsurf(width : Int32, height : Int32, fractal_dimension : Float64)
      Operation.call("fractsurf", width, height, fractal_dimension).as(Type).as_image
    end

    # Frequency-domain filtering
    #
    # ```
    # # out_ = in.freqmult(mask)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input mask image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def freqmult(mask : Image)
      self.call("freqmult", mask).as(Type).as_image
    end

    # Forward fft
    #
    # ```
    # # out_ = in.fwfft()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def fwfft
      self.call("fwfft").as(Type).as_image
    end

    # Gamma an image
    #
    # ```
    # # out_ = in.gamma({exponent: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *exponent* : Float64 - Gamma factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def gamma(**kwargs)
      options = Optional.new(**kwargs)

      self.call("gamma", options).as(Type).as_image
    end

    # Gaussian blur
    #
    # ```
    # # out_ = in.gaussblur(sigma, {min_ampl: Float64, precision: Enums::Precision})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sigma* : Float64 - Sigma of Gaussian
    #
    # _Optionals_
    #
    # *min_ampl* : Float64 - Minimum amplitude of Gaussian
    #
    # *precision* : Enums::Precision - Convolve with this precision
    #
    #
    # **Returns**
    #
    # Output image
    #
    def gaussblur(sigma : Float64, **kwargs)
      options = Optional.new(**kwargs)

      self.call("gaussblur", options, sigma).as(Type).as_image
    end

    # Make a gaussian image
    #
    # ```
    # # out_ = Vips::Image.gaussmat(sigma, min_ampl, {separable: Bool, precision: Enums::Precision})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sigma* : Float64 - Sigma of Gaussian
    #
    # *min_ampl* : Float64 - Minimum amplitude of Gaussian
    #
    # _Optionals_
    #
    # *separable* : Bool - Generate separable Gaussian
    #
    # *precision* : Enums::Precision - Generate with this precision
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.gaussmat(sigma : Float64, min_ampl : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("gaussmat", options, sigma, min_ampl).as(Type).as_image
    end

    # Make a gaussnoise image
    #
    # ```
    # # out_ = Vips::Image.gaussnoise(width, height, {sigma: Float64, mean: Float64, seed: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *sigma* : Float64 - Standard deviation of pixels in generated image
    #
    # *mean* : Float64 - Mean of pixels in generated image
    #
    # *seed* : Int32 - Random number seed
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.gaussnoise(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("gaussnoise", options, width, height).as(Type).as_image
    end

    # Read a point from an image
    #
    # ```
    # # out_array = in.getpoint(x, y)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *x* : Int32 - Point to read
    #
    # *y* : Int32 - Point to read
    #
    #
    # **Returns**
    #
    # Array of output values
    #
    def getpoint(x : Int32, y : Int32)
      self.call("getpoint", x, y).as(Type).as_a64
    end

    # Load gif with libnsgif
    #
    # ```
    # # out_, flags = Vips::Image.gifload(filename, {n: Int32, page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *n* : Int32 - Load this many pages
    #
    # *page* : Int32 - Load this page from the file
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.gifload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("gifload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load gif with libnsgif
    #
    # ```
    # # out_, flags = Vips::Image.gifload_buffer(buffer, {n: Int32, page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *n* : Int32 - Load this many pages
    #
    # *page* : Int32 - Load this page from the file
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.gifload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("gifload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load gif from source
    #
    # ```
    # # out_, flags = Vips::Image.gifload_source(source, {n: Int32, page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *n* : Int32 - Load this many pages
    #
    # *page* : Int32 - Load this page from the file
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.gifload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("gifload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load gif from stream
    #
    # ```
    # # out_, flags = Vips::Image.gifload_stream(stream, {n: Int32, page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *n* : Int32 - Load this many pages
    #
    # *page* : Int32 - Load this page from the file
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.gifload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      gifload_source(source, **kwargs)
    end

    # Save as gif
    #
    # ```
    # in.gifsave(filename, {dither: Float64, effort: Int32, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *effort* : Int32 - Quantisation effort
    #
    # *bitdepth* : Int32 - Number of bits per pixel
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def gifsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("gifsave", options, filename)
    end

    # Save as gif
    #
    # ```
    # # buffer = in.gifsave_buffer({dither: Float64, effort: Int32, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *effort* : Int32 - Quantisation effort
    #
    # *bitdepth* : Int32 - Number of bits per pixel
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def gifsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("gifsave_buffer", options).as(Type).as_bytes
    end

    # Save as gif
    #
    # ```
    # in.gifsave_target(target, {dither: Float64, effort: Int32, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *effort* : Int32 - Quantisation effort
    #
    # *bitdepth* : Int32 - Number of bits per pixel
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def gifsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("gifsave_target", options, target)
    end

    # Save as gif
    #
    # ```
    # in.gifsave_stream(stream, {dither: Float64, effort: Int32, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *effort* : Int32 - Quantisation effort
    #
    # *bitdepth* : Int32 - Number of bits per pixel
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def gifsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      gifsave_target(target, **kwargs)
    end

    # Global balance an image mosaic
    #
    # ```
    # # out_ = in.globalbalance({gamma: Float64, int_output: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *gamma* : Float64 - Image gamma
    #
    # *int_output* : Bool - Integer output
    #
    #
    # **Returns**
    #
    # Output image
    #
    def globalbalance(**kwargs)
      options = Optional.new(**kwargs)

      self.call("globalbalance", options).as(Type).as_image
    end

    # Place an image within a larger image with a certain gravity
    #
    # ```
    # # out_ = in.gravity(direction, width, height, {extend: Enums::Extend, background: Array(Float64)})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *direction* : Enums::CompassDirection - direction to place image within width/height
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *extend* : Enums::Extend - How to generate the extra pixels
    #
    # *background* : Array(Float64) - Color for background pixels
    #
    #
    # **Returns**
    #
    # Output image
    #
    def gravity(direction : Enums::CompassDirection, width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("gravity", options, direction, width, height).as(Type).as_image
    end

    # Make a grey ramp image
    #
    # ```
    # # out_ = Vips::Image.grey(width, height, {uchar: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.grey(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("grey", options, width, height).as(Type).as_image
    end

    # Grid an image
    #
    # ```
    # # out_ = in.grid(tile_height, across, down)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *tile_height* : Int32 - chop into tiles this high
    #
    # *across* : Int32 - number of tiles across
    #
    # *down* : Int32 - number of tiles down
    #
    #
    # **Returns**
    #
    # Output image
    #
    def grid(tile_height : Int32, across : Int32, down : Int32)
      self.call("grid", tile_height, across, down).as(Type).as_image
    end

    # Load a heif image
    #
    # ```
    # # out_, flags = Vips::Image.heifload(filename, {page: Int32, n: Int32, thumbnail: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *thumbnail* : Bool - Fetch thumbnail image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.heifload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("heifload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load a heif image
    #
    # ```
    # # out_, flags = Vips::Image.heifload_buffer(buffer, {page: Int32, n: Int32, thumbnail: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *thumbnail* : Bool - Fetch thumbnail image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.heifload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("heifload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load a heif image
    #
    # ```
    # # out_, flags = Vips::Image.heifload_source(source, {page: Int32, n: Int32, thumbnail: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *thumbnail* : Bool - Fetch thumbnail image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.heifload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("heifload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load a heif image
    #
    # ```
    # # out_, flags = Vips::Image.heifload_stream(stream, {page: Int32, n: Int32, thumbnail: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *thumbnail* : Bool - Fetch thumbnail image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.heifload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      heifload_source(source, **kwargs)
    end

    # Save image in heif format
    #
    # ```
    # in.heifsave(filename, {q: Int32, lossless: Bool, compression: Enums::ForeignHeifCompression, effort: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *compression* : Enums::ForeignHeifCompression - Compression format
    #
    # *effort* : Int32 - CPU effort
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def heifsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("heifsave", options, filename)
    end

    # Save image in heif format
    #
    # ```
    # # buffer = in.heifsave_buffer({q: Int32, lossless: Bool, compression: Enums::ForeignHeifCompression, effort: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *compression* : Enums::ForeignHeifCompression - Compression format
    #
    # *effort* : Int32 - CPU effort
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def heifsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("heifsave_buffer", options).as(Type).as_bytes
    end

    # Save image in heif format
    #
    # ```
    # in.heifsave_target(target, {q: Int32, lossless: Bool, compression: Enums::ForeignHeifCompression, effort: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *compression* : Enums::ForeignHeifCompression - Compression format
    #
    # *effort* : Int32 - CPU effort
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def heifsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("heifsave_target", options, target)
    end

    # Save image in heif format
    #
    # ```
    # in.heifsave_stream(stream, {q: Int32, lossless: Bool, compression: Enums::ForeignHeifCompression, effort: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *compression* : Enums::ForeignHeifCompression - Compression format
    #
    # *effort* : Int32 - CPU effort
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def heifsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      heifsave_target(target, **kwargs)
    end

    # Form cumulative histogram
    #
    # ```
    # # out_ = in.hist_cum()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hist_cum
      self.call("hist_cum").as(Type).as_image
    end

    # Estimate image entropy
    #
    # ```
    # # out_ = in.hist_entropy()
    # ```
    #
    #
    # **Returns**
    #
    # Output value
    #
    def hist_entropy
      self.call("hist_entropy").as(Type).as_f64
    end

    # Histogram equalisation
    #
    # ```
    # # out_ = in.hist_equal({band: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *band* : Int32 - Equalise with this band
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hist_equal(**kwargs)
      options = Optional.new(**kwargs)

      self.call("hist_equal", options).as(Type).as_image
    end

    # Find image histogram
    #
    # ```
    # # out_ = in.hist_find({band: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *band* : Int32 - Find histogram of band
    #
    #
    # **Returns**
    #
    # Output histogram
    #
    def hist_find(**kwargs)
      options = Optional.new(**kwargs)

      self.call("hist_find", options).as(Type).as_image
    end

    # Find indexed image histogram
    #
    # ```
    # # out_ = in.hist_find_indexed(index, {combine: Enums::Combine})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *index* : Image - Index image
    #
    # _Optionals_
    #
    # *combine* : Enums::Combine - Combine bins like this
    #
    #
    # **Returns**
    #
    # Output histogram
    #
    def hist_find_indexed(index : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("hist_find_indexed", options, index).as(Type).as_image
    end

    # Find n-dimensional image histogram
    #
    # ```
    # # out_ = in.hist_find_ndim({bins: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *bins* : Int32 - Number of bins in each dimension
    #
    #
    # **Returns**
    #
    # Output histogram
    #
    def hist_find_ndim(**kwargs)
      options = Optional.new(**kwargs)

      self.call("hist_find_ndim", options).as(Type).as_image
    end

    # Test for monotonicity
    #
    # ```
    # # monotonic = in.hist_ismonotonic()
    # ```
    #
    #
    # **Returns**
    #
    # true if in is monotonic
    #
    def hist_ismonotonic
      self.call("hist_ismonotonic").as(Type).as_b
    end

    # Local histogram equalisation
    #
    # ```
    # # out_ = in.hist_local(width, height, {max_slope: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Window width in pixels
    #
    # *height* : Int32 - Window height in pixels
    #
    # _Optionals_
    #
    # *max_slope* : Int32 - Maximum slope (CLAHE)
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hist_local(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("hist_local", options, width, height).as(Type).as_image
    end

    # Match two histograms
    #
    # ```
    # # out_ = in.hist_match(ref)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *ref* : Image - Reference histogram
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hist_match(ref : Image)
      self.call("hist_match", ref).as(Type).as_image
    end

    # Normalise histogram
    #
    # ```
    # # out_ = in.hist_norm()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hist_norm
      self.call("hist_norm").as(Type).as_image
    end

    # Plot histogram
    #
    # ```
    # # out_ = in.hist_plot()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hist_plot
      self.call("hist_plot").as(Type).as_image
    end

    # Find hough circle transform
    #
    # ```
    # # out_ = in.hough_circle({scale: Int32, min_radius: Int32, max_radius: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *scale* : Int32 - Scale down dimensions by this factor
    #
    # *min_radius* : Int32 - Smallest radius to search for
    #
    # *max_radius* : Int32 - Largest radius to search for
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hough_circle(**kwargs)
      options = Optional.new(**kwargs)

      self.call("hough_circle", options).as(Type).as_image
    end

    # Find hough line transform
    #
    # ```
    # # out_ = in.hough_line({width: Int32, height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *width* : Int32 - horizontal size of parameter space
    #
    # *height* : Int32 - Vertical size of parameter space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hough_line(**kwargs)
      options = Optional.new(**kwargs)

      self.call("hough_line", options).as(Type).as_image
    end

    # Transform hsv to srgb
    #
    # ```
    # # out_ = in.hsv2srgb()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def hsv2srgb
      self.call("hsv2srgb").as(Type).as_image
    end

    # Output to device with icc profile
    #
    # ```
    # # out_ = in.icc_export({pcs: Enums::PCS, intent: Enums::Intent, black_point_compensation: Bool, output_profile: String, depth: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *pcs* : Enums::PCS - Set Profile Connection Space
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    # *black_point_compensation* : Bool - Enable black point compensation
    #
    # *output_profile* : String - Filename to load output profile from
    #
    # *depth* : Int32 - Output device space depth in bits
    #
    #
    # **Returns**
    #
    # Output image
    #
    def icc_export(**kwargs)
      options = Optional.new(**kwargs)

      self.call("icc_export", options).as(Type).as_image
    end

    # Import from device with icc profile
    #
    # ```
    # # out_ = in.icc_import({pcs: Enums::PCS, intent: Enums::Intent, black_point_compensation: Bool, embedded: Bool, input_profile: String})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *pcs* : Enums::PCS - Set Profile Connection Space
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    # *black_point_compensation* : Bool - Enable black point compensation
    #
    # *embedded* : Bool - Use embedded input profile, if available
    #
    # *input_profile* : String - Filename to load input profile from
    #
    #
    # **Returns**
    #
    # Output image
    #
    def icc_import(**kwargs)
      options = Optional.new(**kwargs)

      self.call("icc_import", options).as(Type).as_image
    end

    # Transform between devices with icc profiles
    #
    # ```
    # # out_ = in.icc_transform(output_profile, {pcs: Enums::PCS, intent: Enums::Intent, black_point_compensation: Bool, embedded: Bool, input_profile: String, depth: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *output_profile* : String - Filename to load output profile from
    #
    # _Optionals_
    #
    # *pcs* : Enums::PCS - Set Profile Connection Space
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    # *black_point_compensation* : Bool - Enable black point compensation
    #
    # *embedded* : Bool - Use embedded input profile, if available
    #
    # *input_profile* : String - Filename to load input profile from
    #
    # *depth* : Int32 - Output device space depth in bits
    #
    #
    # **Returns**
    #
    # Output image
    #
    def icc_transform(output_profile : String, **kwargs)
      options = Optional.new(**kwargs)

      self.call("icc_transform", options, output_profile).as(Type).as_image
    end

    # Make a 1d image where pixel values are indexes
    #
    # ```
    # # out_ = Vips::Image.identity({bands: Int32, ushort: Bool, size: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *bands* : Int32 - Number of bands in LUT
    #
    # *ushort* : Bool - Create a 16-bit LUT
    #
    # *size* : Int32 - Size of 16-bit LUT
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.identity(**kwargs)
      options = Optional.new(**kwargs)

      Operation.call("identity", options).as(Type).as_image
    end

    # Insert image @sub into @main at @x, @y
    #
    # ```
    # # out_ = main.insert(sub, x, y, {expand: Bool, background: Array(Float64)})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sub* : Image - Sub-image to insert into main image
    #
    # *x* : Int32 - Left edge of sub in main
    #
    # *y* : Int32 - Top edge of sub in main
    #
    # _Optionals_
    #
    # *expand* : Bool - Expand output to hold all of both inputs
    #
    # *background* : Array(Float64) - Color for new pixels
    #
    #
    # **Returns**
    #
    # Output image
    #
    def insert(sub : Image, x : Int32, y : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("insert", options, sub, x, y).as(Type).as_image
    end

    # Invert an image
    #
    # ```
    # # out_ = in.invert()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def invert
      self.call("invert").as(Type).as_image
    end

    # Build an inverted look-up table
    #
    # ```
    # # out_ = in.invertlut({size: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *size* : Int32 - LUT size to generate
    #
    #
    # **Returns**
    #
    # Output image
    #
    def invertlut(**kwargs)
      options = Optional.new(**kwargs)

      self.call("invertlut", options).as(Type).as_image
    end

    # Inverse fft
    #
    # ```
    # # out_ = in.invfft({real: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *real* : Bool - Output only the real part of the transform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def invfft(**kwargs)
      options = Optional.new(**kwargs)

      self.call("invfft", options).as(Type).as_image
    end

    # Join a pair of images
    #
    # ```
    # # out_ = in1.join(in2, direction, {expand: Bool, shim: Int32, background: Array(Float64), align: Enums::Align})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *in2* : Image - Second input image
    #
    # *direction* : Enums::Direction - Join left-right or up-down
    #
    # _Optionals_
    #
    # *expand* : Bool - Expand output to hold all of both inputs
    #
    # *shim* : Int32 - Pixels between images
    #
    # *background* : Array(Float64) - Colour for new pixels
    #
    # *align* : Enums::Align - Align on the low, centre or high coordinate edge
    #
    #
    # **Returns**
    #
    # Output image
    #
    def join(in2 : Image, direction : Enums::Direction, **kwargs)
      options = Optional.new(**kwargs)

      self.call("join", options, in2, direction).as(Type).as_image
    end

    # Load jpeg2000 image
    #
    # ```
    # # out_, flags = Vips::Image.jp2kload(filename, {page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jp2kload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jp2kload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg2000 image
    #
    # ```
    # # out_, flags = Vips::Image.jp2kload_buffer(buffer, {page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jp2kload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jp2kload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg2000 image
    #
    # ```
    # # out_, flags = Vips::Image.jp2kload_source(source, {page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jp2kload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jp2kload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg2000 image
    #
    # ```
    # # out_, flags = Vips::Image.jp2kload_stream(stream, {page: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.jp2kload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      jp2kload_source(source, **kwargs)
    end

    # Save image in jpeg2000 format
    #
    # ```
    # in.jp2ksave(filename, {tile_width: Int32, tile_height: Int32, lossless: Bool, q: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Q factor
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jp2ksave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("jp2ksave", options, filename)
    end

    # Save image in jpeg2000 format
    #
    # ```
    # # buffer = in.jp2ksave_buffer({tile_width: Int32, tile_height: Int32, lossless: Bool, q: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Q factor
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def jp2ksave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("jp2ksave_buffer", options).as(Type).as_bytes
    end

    # Save image in jpeg2000 format
    #
    # ```
    # in.jp2ksave_target(target, {tile_width: Int32, tile_height: Int32, lossless: Bool, q: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Q factor
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jp2ksave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("jp2ksave_target", options, target)
    end

    # Save image in jpeg2000 format
    #
    # ```
    # in.jp2ksave_stream(stream, {tile_width: Int32, tile_height: Int32, lossless: Bool, q: Int32, subsample_mode: Enums::ForeignSubsample, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Q factor
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def jp2ksave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      jp2ksave_target(target, **kwargs)
    end

    # Load jpeg from file
    #
    # ```
    # # out_, flags = Vips::Image.jpegload(filename, {shrink: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *shrink* : Int32 - Shrink factor on load
    #
    # *autorotate* : Bool - Rotate image using exif orientation
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jpegload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jpegload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg from buffer
    #
    # ```
    # # out_, flags = Vips::Image.jpegload_buffer(buffer, {shrink: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *shrink* : Int32 - Shrink factor on load
    #
    # *autorotate* : Bool - Rotate image using exif orientation
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jpegload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jpegload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load image from jpeg source
    #
    # ```
    # # out_, flags = Vips::Image.jpegload_source(source, {shrink: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *shrink* : Int32 - Shrink factor on load
    #
    # *autorotate* : Bool - Rotate image using exif orientation
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jpegload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jpegload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load image from jpeg stream
    #
    # ```
    # # out_, flags = Vips::Image.jpegload_stream(stream, {shrink: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *shrink* : Int32 - Shrink factor on load
    #
    # *autorotate* : Bool - Rotate image using exif orientation
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.jpegload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      jpegload_source(source, **kwargs)
    end

    # Save image to jpeg file
    #
    # ```
    # in.jpegsave(filename, {q: Int32, profile: String, optimize_coding: Bool, interlace: Bool, trellis_quant: Bool, overshoot_deringing: Bool, optimize_scans: Bool, quant_table: Int32, subsample_mode: Enums::ForeignSubsample, restart_interval: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *profile* : String - ICC profile to embed
    #
    # *optimize_coding* : Bool - Compute optimal Huffman coding tables
    #
    # *interlace* : Bool - Generate an interlaced (progressive) jpeg
    #
    # *trellis_quant* : Bool - Apply trellis quantisation to each 8x8 block
    #
    # *overshoot_deringing* : Bool - Apply overshooting to samples with extreme values
    #
    # *optimize_scans* : Bool - Split spectrum of DCT coefficients into separate scans
    #
    # *quant_table* : Int32 - Use predefined quantization table with given index
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *restart_interval* : Int32 - Add restart markers every specified number of mcu
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jpegsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("jpegsave", options, filename)
    end

    # Save image to jpeg buffer
    #
    # ```
    # # buffer = in.jpegsave_buffer({q: Int32, profile: String, optimize_coding: Bool, interlace: Bool, trellis_quant: Bool, overshoot_deringing: Bool, optimize_scans: Bool, quant_table: Int32, subsample_mode: Enums::ForeignSubsample, restart_interval: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *profile* : String - ICC profile to embed
    #
    # *optimize_coding* : Bool - Compute optimal Huffman coding tables
    #
    # *interlace* : Bool - Generate an interlaced (progressive) jpeg
    #
    # *trellis_quant* : Bool - Apply trellis quantisation to each 8x8 block
    #
    # *overshoot_deringing* : Bool - Apply overshooting to samples with extreme values
    #
    # *optimize_scans* : Bool - Split spectrum of DCT coefficients into separate scans
    #
    # *quant_table* : Int32 - Use predefined quantization table with given index
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *restart_interval* : Int32 - Add restart markers every specified number of mcu
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def jpegsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("jpegsave_buffer", options).as(Type).as_bytes
    end

    # Save image to jpeg mime
    #
    # ```
    # in.jpegsave_mime({q: Int32, profile: String, optimize_coding: Bool, interlace: Bool, trellis_quant: Bool, overshoot_deringing: Bool, optimize_scans: Bool, quant_table: Int32, subsample_mode: Enums::ForeignSubsample, restart_interval: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *profile* : String - ICC profile to embed
    #
    # *optimize_coding* : Bool - Compute optimal Huffman coding tables
    #
    # *interlace* : Bool - Generate an interlaced (progressive) jpeg
    #
    # *trellis_quant* : Bool - Apply trellis quantisation to each 8x8 block
    #
    # *overshoot_deringing* : Bool - Apply overshooting to samples with extreme values
    #
    # *optimize_scans* : Bool - Split spectrum of DCT coefficients into separate scans
    #
    # *quant_table* : Int32 - Use predefined quantization table with given index
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *restart_interval* : Int32 - Add restart markers every specified number of mcu
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jpegsave_mime(**kwargs)
      options = Optional.new(**kwargs)
      self.call("jpegsave_mime", options)
    end

    # Save image to jpeg target
    #
    # ```
    # in.jpegsave_target(target, {q: Int32, profile: String, optimize_coding: Bool, interlace: Bool, trellis_quant: Bool, overshoot_deringing: Bool, optimize_scans: Bool, quant_table: Int32, subsample_mode: Enums::ForeignSubsample, restart_interval: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *profile* : String - ICC profile to embed
    #
    # *optimize_coding* : Bool - Compute optimal Huffman coding tables
    #
    # *interlace* : Bool - Generate an interlaced (progressive) jpeg
    #
    # *trellis_quant* : Bool - Apply trellis quantisation to each 8x8 block
    #
    # *overshoot_deringing* : Bool - Apply overshooting to samples with extreme values
    #
    # *optimize_scans* : Bool - Split spectrum of DCT coefficients into separate scans
    #
    # *quant_table* : Int32 - Use predefined quantization table with given index
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *restart_interval* : Int32 - Add restart markers every specified number of mcu
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jpegsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("jpegsave_target", options, target)
    end

    # Save image to jpeg stream
    #
    # ```
    # in.jpegsave_stream(stream, {q: Int32, profile: String, optimize_coding: Bool, interlace: Bool, trellis_quant: Bool, overshoot_deringing: Bool, optimize_scans: Bool, quant_table: Int32, subsample_mode: Enums::ForeignSubsample, restart_interval: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *profile* : String - ICC profile to embed
    #
    # *optimize_coding* : Bool - Compute optimal Huffman coding tables
    #
    # *interlace* : Bool - Generate an interlaced (progressive) jpeg
    #
    # *trellis_quant* : Bool - Apply trellis quantisation to each 8x8 block
    #
    # *overshoot_deringing* : Bool - Apply overshooting to samples with extreme values
    #
    # *optimize_scans* : Bool - Split spectrum of DCT coefficients into separate scans
    #
    # *quant_table* : Int32 - Use predefined quantization table with given index
    #
    # *subsample_mode* : Enums::ForeignSubsample - Select chroma subsample operation mode
    #
    # *restart_interval* : Int32 - Add restart markers every specified number of mcu
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def jpegsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      jpegsave_target(target, **kwargs)
    end

    # Load jpeg-xl image
    #
    # ```
    # # out_, flags = Vips::Image.jxlload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jxlload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jxlload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg-xl image
    #
    # ```
    # # out_, flags = Vips::Image.jxlload_buffer(buffer, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jxlload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jxlload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg-xl image
    #
    # ```
    # # out_, flags = Vips::Image.jxlload_source(source, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.jxlload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("jxlload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load jpeg-xl image
    #
    # ```
    # # out_, flags = Vips::Image.jxlload_stream(stream, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.jxlload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      jxlload_source(source, **kwargs)
    end

    # Save image in jpeg-xl format
    #
    # ```
    # in.jxlsave(filename, {tier: Int32, distance: Float64, effort: Int32, lossless: Bool, q: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *tier* : Int32 - Decode speed tier
    #
    # *distance* : Float64 - Target butteraugli distance
    #
    # *effort* : Int32 - Encoding effort
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Quality factor
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jxlsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("jxlsave", options, filename)
    end

    # Save image in jpeg-xl format
    #
    # ```
    # # buffer = in.jxlsave_buffer({tier: Int32, distance: Float64, effort: Int32, lossless: Bool, q: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *tier* : Int32 - Decode speed tier
    #
    # *distance* : Float64 - Target butteraugli distance
    #
    # *effort* : Int32 - Encoding effort
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Quality factor
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def jxlsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("jxlsave_buffer", options).as(Type).as_bytes
    end

    # Save image in jpeg-xl format
    #
    # ```
    # in.jxlsave_target(target, {tier: Int32, distance: Float64, effort: Int32, lossless: Bool, q: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *tier* : Int32 - Decode speed tier
    #
    # *distance* : Float64 - Target butteraugli distance
    #
    # *effort* : Int32 - Encoding effort
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Quality factor
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def jxlsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("jxlsave_target", options, target)
    end

    # Save image in jpeg-xl format
    #
    # ```
    # in.jxlsave_stream(stream, {tier: Int32, distance: Float64, effort: Int32, lossless: Bool, q: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *tier* : Int32 - Decode speed tier
    #
    # *distance* : Float64 - Target butteraugli distance
    #
    # *effort* : Int32 - Encoding effort
    #
    # *lossless* : Bool - Enable lossless compression
    #
    # *q* : Int32 - Quality factor
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def jxlsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      jxlsave_target(target, **kwargs)
    end

    # Transform float lab to labq coding
    #
    # ```
    # # out_ = in.lab2labq()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def lab2labq
      self.call("lab2labq").as(Type).as_image
    end

    # Transform float lab to signed short
    #
    # ```
    # # out_ = in.lab2labs()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def lab2labs
      self.call("lab2labs").as(Type).as_image
    end

    # Transform lab to lch
    #
    # ```
    # # out_ = in.lab2lch()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def lab2lch
      self.call("lab2lch").as(Type).as_image
    end

    # Transform cielab to xyz
    #
    # ```
    # # out_ = in.lab2xyz({temp: Array(Float64)})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *temp* : Array(Float64) - Color temperature
    #
    #
    # **Returns**
    #
    # Output image
    #
    def lab2xyz(**kwargs)
      options = Optional.new(**kwargs)

      self.call("lab2xyz", options).as(Type).as_image
    end

    # Label regions in an image
    #
    # ```
    # # mask, segments = in.labelregions()
    # ```
    #
    #
    # **Returns**
    #
    # Mask of region labels
    #
    # _Optionals_
    #
    # *segments* : Int32? - Number of discrete contigious regions
    #
    def labelregions
      optional_output = Optional.new(**{segments: true})

      results = self.call("labelregions", optional_output).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      segments = ((o = opts) && (val = o["segments"]?)) ? val.as_i32 : nil
      {final_result, segments}
    end

    # Unpack a labq image to float lab
    #
    # ```
    # # out_ = in.labq2lab()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def labq2lab
      self.call("labq2lab").as(Type).as_image
    end

    # Unpack a labq image to short lab
    #
    # ```
    # # out_ = in.labq2labs()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def labq2labs
      self.call("labq2labs").as(Type).as_image
    end

    # Convert a labq image to srgb
    #
    # ```
    # # out_ = in.labq2srgb()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def labq2srgb
      self.call("labq2srgb").as(Type).as_image
    end

    # Transform signed short lab to float
    #
    # ```
    # # out_ = in.labs2lab()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def labs2lab
      self.call("labs2lab").as(Type).as_image
    end

    # Transform short lab to labq coding
    #
    # ```
    # # out_ = in.labs2labq()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def labs2labq
      self.call("labs2labq").as(Type).as_image
    end

    # Transform lch to cmc
    #
    # ```
    # # out_ = in.lch2cmc()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def lch2cmc
      self.call("lch2cmc").as(Type).as_image
    end

    # Transform lch to lab
    #
    # ```
    # # out_ = in.lch2lab()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def lch2lab
      self.call("lch2lab").as(Type).as_image
    end

    # Calculate (a * in + b)
    #
    # ```
    # # out_ = in.linear(a, b, {uchar: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *a* : Array(Float64) - Multiply by this
    #
    # *b* : Array(Float64) - Add this
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output should be uchar
    #
    #
    # **Returns**
    #
    # Output image
    #
    def linear(a : Array(Float64), b : Array(Float64), **kwargs)
      options = Optional.new(**kwargs)

      self.call("linear", options, a, b).as(Type).as_image
    end

    # Cache an image as a set of lines
    #
    # ```
    # # out_ = in.linecache({tile_height: Int32, access: Enums::Access, threaded: Bool, persistent: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *access* : Enums::Access - Expected access pattern
    #
    # *threaded* : Bool - Allow threaded access
    #
    # *persistent* : Bool - Keep cache between evaluations
    #
    #
    # **Returns**
    #
    # Output image
    #
    def linecache(**kwargs)
      options = Optional.new(**kwargs)

      self.call("linecache", options).as(Type).as_image
    end

    # Make a laplacian of gaussian image
    #
    # ```
    # # out_ = Vips::Image.logmat(sigma, min_ampl, {separable: Bool, precision: Enums::Precision})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sigma* : Float64 - Radius of Gaussian
    #
    # *min_ampl* : Float64 - Minimum amplitude of Gaussian
    #
    # _Optionals_
    #
    # *separable* : Bool - Generate separable Gaussian
    #
    # *precision* : Enums::Precision - Generate with this precision
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.logmat(sigma : Float64, min_ampl : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("logmat", options, sigma, min_ampl).as(Type).as_image
    end

    # Load file with imagemagick7
    #
    # ```
    # # out_, flags = Vips::Image.magickload(filename, {density: String, page: Int32, n: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *density* : String - Canvas resolution for rendering vector formats like SVG
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.magickload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("magickload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load buffer with imagemagick7
    #
    # ```
    # # out_, flags = Vips::Image.magickload_buffer(buffer, {density: String, page: Int32, n: Int32, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *density* : String - Canvas resolution for rendering vector formats like SVG
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.magickload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("magickload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Save file with imagemagick
    #
    # ```
    # in.magicksave(filename, {format: String, quality: Int32, optimize_gif_frames: Bool, optimize_gif_transparency: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *format* : String - Format to save in
    #
    # *quality* : Int32 - Quality to use
    #
    # *optimize_gif_frames* : Bool - Apply GIF frames optimization
    #
    # *optimize_gif_transparency* : Bool - Apply GIF transparency optimization
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def magicksave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("magicksave", options, filename)
    end

    # Save bmp image with imagemagick
    #
    # ```
    # in.magicksave_bmp(filename, {format: String, quality: Int32, optimize_gif_frames: Bool, optimize_gif_transparency: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *format* : String - Format to save in
    #
    # *quality* : Int32 - Quality to use
    #
    # *optimize_gif_frames* : Bool - Apply GIF frames optimization
    #
    # *optimize_gif_transparency* : Bool - Apply GIF transparency optimization
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def magicksave_bmp(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("magicksave_bmp", options, filename)
    end

    # Save bmp image to magick buffer
    #
    # ```
    # # buffer = in.magicksave_bmp_buffer({format: String, quality: Int32, optimize_gif_frames: Bool, optimize_gif_transparency: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *format* : String - Format to save in
    #
    # *quality* : Int32 - Quality to use
    #
    # *optimize_gif_frames* : Bool - Apply GIF frames optimization
    #
    # *optimize_gif_transparency* : Bool - Apply GIF transparency optimization
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def magicksave_bmp_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("magicksave_bmp_buffer", options).as(Type).as_bytes
    end

    # Save image to magick buffer
    #
    # ```
    # # buffer = in.magicksave_buffer({format: String, quality: Int32, optimize_gif_frames: Bool, optimize_gif_transparency: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *format* : String - Format to save in
    #
    # *quality* : Int32 - Quality to use
    #
    # *optimize_gif_frames* : Bool - Apply GIF frames optimization
    #
    # *optimize_gif_transparency* : Bool - Apply GIF transparency optimization
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def magicksave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("magicksave_buffer", options).as(Type).as_bytes
    end

    # Save gif image with imagemagick
    #
    # ```
    # in.magicksave_gif(filename, {format: String, quality: Int32, optimize_gif_frames: Bool, optimize_gif_transparency: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *format* : String - Format to save in
    #
    # *quality* : Int32 - Quality to use
    #
    # *optimize_gif_frames* : Bool - Apply GIF frames optimization
    #
    # *optimize_gif_transparency* : Bool - Apply GIF transparency optimization
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def magicksave_gif(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("magicksave_gif", options, filename)
    end

    # Save gif image to magick buffer
    #
    # ```
    # # buffer = in.magicksave_gif_buffer({format: String, quality: Int32, optimize_gif_frames: Bool, optimize_gif_transparency: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *format* : String - Format to save in
    #
    # *quality* : Int32 - Quality to use
    #
    # *optimize_gif_frames* : Bool - Apply GIF frames optimization
    #
    # *optimize_gif_transparency* : Bool - Apply GIF transparency optimization
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def magicksave_gif_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("magicksave_gif_buffer", options).as(Type).as_bytes
    end

    # Resample with a map image
    #
    # ```
    # # out_ = in.mapim(index, {interpolate: Interpolate})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *index* : Image - Index pixels with this
    #
    # _Optionals_
    #
    # *interpolate* : Interpolate - Interpolate pixels with this
    #
    #
    # **Returns**
    #
    # Output image
    #
    def mapim(index : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("mapim", options, index).as(Type).as_image
    end

    # Map an image though a lut
    #
    # ```
    # # out_ = in.maplut(lut, {band: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *lut* : Image - Look-up table image
    #
    # _Optionals_
    #
    # *band* : Int32 - apply one-band lut to this band of in
    #
    #
    # **Returns**
    #
    # Output image
    #
    def maplut(lut : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("maplut", options, lut).as(Type).as_image
    end

    # Make a butterworth filter
    #
    # ```
    # # out_ = Vips::Image.mask_butterworth(width, height, order, frequency_cutoff, amplitude_cutoff, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *order* : Float64 - Filter order
    #
    # *frequency_cutoff* : Float64 - Frequency cutoff
    #
    # *amplitude_cutoff* : Float64 - Amplitude cutoff
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_butterworth(width : Int32, height : Int32, order : Float64, frequency_cutoff : Float64, amplitude_cutoff : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_butterworth", options, width, height, order, frequency_cutoff, amplitude_cutoff).as(Type).as_image
    end

    # Make a butterworth_band filter
    #
    # ```
    # # out_ = Vips::Image.mask_butterworth_band(width, height, order, frequency_cutoff_x, frequency_cutoff_y, radius, amplitude_cutoff, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *order* : Float64 - Filter order
    #
    # *frequency_cutoff_x* : Float64 - Frequency cutoff x
    #
    # *frequency_cutoff_y* : Float64 - Frequency cutoff y
    #
    # *radius* : Float64 - radius of circle
    #
    # *amplitude_cutoff* : Float64 - Amplitude cutoff
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_butterworth_band(width : Int32, height : Int32, order : Float64, frequency_cutoff_x : Float64, frequency_cutoff_y : Float64, radius : Float64, amplitude_cutoff : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_butterworth_band", options, width, height, order, frequency_cutoff_x, frequency_cutoff_y, radius, amplitude_cutoff).as(Type).as_image
    end

    # Make a butterworth ring filter
    #
    # ```
    # # out_ = Vips::Image.mask_butterworth_ring(width, height, order, frequency_cutoff, amplitude_cutoff, ringwidth, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *order* : Float64 - Filter order
    #
    # *frequency_cutoff* : Float64 - Frequency cutoff
    #
    # *amplitude_cutoff* : Float64 - Amplitude cutoff
    #
    # *ringwidth* : Float64 - Ringwidth
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_butterworth_ring(width : Int32, height : Int32, order : Float64, frequency_cutoff : Float64, amplitude_cutoff : Float64, ringwidth : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_butterworth_ring", options, width, height, order, frequency_cutoff, amplitude_cutoff, ringwidth).as(Type).as_image
    end

    # Make fractal filter
    #
    # ```
    # # out_ = Vips::Image.mask_fractal(width, height, fractal_dimension, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *fractal_dimension* : Float64 - Fractal dimension
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_fractal(width : Int32, height : Int32, fractal_dimension : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_fractal", options, width, height, fractal_dimension).as(Type).as_image
    end

    # Make a gaussian filter
    #
    # ```
    # # out_ = Vips::Image.mask_gaussian(width, height, frequency_cutoff, amplitude_cutoff, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *frequency_cutoff* : Float64 - Frequency cutoff
    #
    # *amplitude_cutoff* : Float64 - Amplitude cutoff
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_gaussian(width : Int32, height : Int32, frequency_cutoff : Float64, amplitude_cutoff : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_gaussian", options, width, height, frequency_cutoff, amplitude_cutoff).as(Type).as_image
    end

    # Make a gaussian filter
    #
    # ```
    # # out_ = Vips::Image.mask_gaussian_band(width, height, frequency_cutoff_x, frequency_cutoff_y, radius, amplitude_cutoff, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *frequency_cutoff_x* : Float64 - Frequency cutoff x
    #
    # *frequency_cutoff_y* : Float64 - Frequency cutoff y
    #
    # *radius* : Float64 - radius of circle
    #
    # *amplitude_cutoff* : Float64 - Amplitude cutoff
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_gaussian_band(width : Int32, height : Int32, frequency_cutoff_x : Float64, frequency_cutoff_y : Float64, radius : Float64, amplitude_cutoff : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_gaussian_band", options, width, height, frequency_cutoff_x, frequency_cutoff_y, radius, amplitude_cutoff).as(Type).as_image
    end

    # Make a gaussian ring filter
    #
    # ```
    # # out_ = Vips::Image.mask_gaussian_ring(width, height, frequency_cutoff, amplitude_cutoff, ringwidth, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *frequency_cutoff* : Float64 - Frequency cutoff
    #
    # *amplitude_cutoff* : Float64 - Amplitude cutoff
    #
    # *ringwidth* : Float64 - Ringwidth
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_gaussian_ring(width : Int32, height : Int32, frequency_cutoff : Float64, amplitude_cutoff : Float64, ringwidth : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_gaussian_ring", options, width, height, frequency_cutoff, amplitude_cutoff, ringwidth).as(Type).as_image
    end

    # Make an ideal filter
    #
    # ```
    # # out_ = Vips::Image.mask_ideal(width, height, frequency_cutoff, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *frequency_cutoff* : Float64 - Frequency cutoff
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_ideal(width : Int32, height : Int32, frequency_cutoff : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_ideal", options, width, height, frequency_cutoff).as(Type).as_image
    end

    # Make an ideal band filter
    #
    # ```
    # # out_ = Vips::Image.mask_ideal_band(width, height, frequency_cutoff_x, frequency_cutoff_y, radius, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *frequency_cutoff_x* : Float64 - Frequency cutoff x
    #
    # *frequency_cutoff_y* : Float64 - Frequency cutoff y
    #
    # *radius* : Float64 - radius of circle
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_ideal_band(width : Int32, height : Int32, frequency_cutoff_x : Float64, frequency_cutoff_y : Float64, radius : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_ideal_band", options, width, height, frequency_cutoff_x, frequency_cutoff_y, radius).as(Type).as_image
    end

    # Make an ideal ring filter
    #
    # ```
    # # out_ = Vips::Image.mask_ideal_ring(width, height, frequency_cutoff, ringwidth, {uchar: Bool, nodc: Bool, reject: Bool, optical: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *frequency_cutoff* : Float64 - Frequency cutoff
    #
    # *ringwidth* : Float64 - Ringwidth
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *nodc* : Bool - Remove DC component
    #
    # *reject* : Bool - Invert the sense of the filter
    #
    # *optical* : Bool - Rotate quadrants to optical space
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.mask_ideal_ring(width : Int32, height : Int32, frequency_cutoff : Float64, ringwidth : Float64, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("mask_ideal_ring", options, width, height, frequency_cutoff, ringwidth).as(Type).as_image
    end

    # First-order match of two images
    #
    # ```
    # # out_ = ref.match(sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, {hwindow: Int32, harea: Int32, search: Bool, interpolate: Interpolate})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sec* : Image - Secondary image
    #
    # *xr1* : Int32 - Position of first reference tie-point
    #
    # *yr1* : Int32 - Position of first reference tie-point
    #
    # *xs1* : Int32 - Position of first secondary tie-point
    #
    # *ys1* : Int32 - Position of first secondary tie-point
    #
    # *xr2* : Int32 - Position of second reference tie-point
    #
    # *yr2* : Int32 - Position of second reference tie-point
    #
    # *xs2* : Int32 - Position of second secondary tie-point
    #
    # *ys2* : Int32 - Position of second secondary tie-point
    #
    # _Optionals_
    #
    # *hwindow* : Int32 - Half window size
    #
    # *harea* : Int32 - Half area size
    #
    # *search* : Bool - Search to improve tie-points
    #
    # *interpolate* : Interpolate - Interpolate pixels with this
    #
    #
    # **Returns**
    #
    # Output image
    #
    def match(sec : Image, xr1 : Int32, yr1 : Int32, xs1 : Int32, ys1 : Int32, xr2 : Int32, yr2 : Int32, xs2 : Int32, ys2 : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("match", options, sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2).as(Type).as_image
    end

    # Apply a math operation to an image
    #
    # ```
    # # out_ = in.math(math)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *math* : Enums::OperationMath - math to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def math(math : Enums::OperationMath)
      self.call("math", math).as(Type).as_image
    end

    # Binary math operations
    #
    # ```
    # # out_ = left.math2(right, math2)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    # *math2* : Enums::OperationMath2 - math to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def math2(right : Image, math2 : Enums::OperationMath2)
      self.call("math2", right, math2).as(Type).as_image
    end

    # Binary math operations with a constant
    #
    # ```
    # # out_ = in.math2_const(math2, c)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *math2* : Enums::OperationMath2 - math to perform
    #
    # *c* : Array(Float64) - Array of constants
    #
    #
    # **Returns**
    #
    # Output image
    #
    def math2_const(math2 : Enums::OperationMath2, c : Array(Float64))
      self.call("math2_const", math2, c).as(Type).as_image
    end

    # Load mat from file
    #
    # ```
    # # out_, flags = Vips::Image.matload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.matload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("matload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Invert an matrix
    #
    # ```
    # # out_ = in.matrixinvert()
    # ```
    #
    #
    # **Returns**
    #
    # Output matrix
    #
    def matrixinvert
      self.call("matrixinvert").as(Type).as_image
    end

    # Load matrix
    #
    # ```
    # # out_, flags = Vips::Image.matrixload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.matrixload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("matrixload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load matrix
    #
    # ```
    # # out_, flags = Vips::Image.matrixload_source(source, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.matrixload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("matrixload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load matrix
    #
    # ```
    # # out_, flags = Vips::Image.matrixload_stream(stream, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.matrixload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      matrixload_source(source, **kwargs)
    end

    # Print matrix
    #
    # ```
    # in.matrixprint({strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def matrixprint(**kwargs)
      options = Optional.new(**kwargs)
      self.call("matrixprint", options)
    end

    # Save image to matrix
    #
    # ```
    # in.matrixsave(filename, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def matrixsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("matrixsave", options, filename)
    end

    # Save image to matrix
    #
    # ```
    # in.matrixsave_target(target, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def matrixsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("matrixsave_target", options, target)
    end

    # Save image to matrix
    #
    # ```
    # in.matrixsave_stream(stream, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def matrixsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      matrixsave_target(target, **kwargs)
    end

    # Find image maximum
    #
    # ```
    # # out_, x, y, out_array, x_array, y_array = in.max({size: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *size* : Int32 - Number of maximum values to find
    #
    #
    # **Returns**
    #
    # Output value
    #
    # _Optionals_
    #
    # *x* : Int32? - Horizontal position of maximum
    #
    # *y* : Int32? - Vertical position of maximum
    #
    # *out_array* : Array(Float64)? - Array of output values
    #
    # *x_array* : Array(Int32)? - Array of horizontal positions
    #
    # *y_array* : Array(Int32)? - Array of vertical positions
    #
    def max(**kwargs)
      options = Optional.new(**kwargs)
      options["x"] = true
      options["y"] = true
      options["out_array"] = true
      options["x_array"] = true
      options["y_array"] = true

      results = self.call("max", options).as(Array(Type))
      final_result = results.first.as(Type).as_f64

      opts = results[1]?.try &.as_h

      x = ((o = opts) && (val = o["x"]?)) ? val.as_i32 : nil
      y = ((o = opts) && (val = o["y"]?)) ? val.as_i32 : nil
      out_array = ((o = opts) && (val = o["out_array"]?)) ? val.as_a64 : nil
      x_array = ((o = opts) && (val = o["x_array"]?)) ? val.as_a32 : nil
      y_array = ((o = opts) && (val = o["y_array"]?)) ? val.as_a32 : nil
      {final_result, x, y, out_array, x_array, y_array}
    end

    # Measure a set of patches on a color chart
    #
    # ```
    # # out_ = in.measure(h, v, {left: Int32, top: Int32, width: Int32, height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *h* : Int32 - Number of patches across chart
    #
    # *v* : Int32 - Number of patches down chart
    #
    # _Optionals_
    #
    # *left* : Int32 - Left edge of extract area
    #
    # *top* : Int32 - Top edge of extract area
    #
    # *width* : Int32 - Width of extract area
    #
    # *height* : Int32 - Height of extract area
    #
    #
    # **Returns**
    #
    # Output array of statistics
    #
    def measure(h : Int32, v : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("measure", options, h, v).as(Type).as_image
    end

    # Merge two images
    #
    # ```
    # # out_ = ref.merge(sec, direction, dx, dy, {mblend: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sec* : Image - Secondary image
    #
    # *direction* : Enums::Direction - Horizontal or vertical merge
    #
    # *dx* : Int32 - Horizontal displacement from sec to ref
    #
    # *dy* : Int32 - Vertical displacement from sec to ref
    #
    # _Optionals_
    #
    # *mblend* : Int32 - Maximum blend size
    #
    #
    # **Returns**
    #
    # Output image
    #
    def merge(sec : Image, direction : Enums::Direction, dx : Int32, dy : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("merge", options, sec, direction, dx, dy).as(Type).as_image
    end

    # Find image minimum
    #
    # ```
    # # out_, x, y, out_array, x_array, y_array = in.min({size: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *size* : Int32 - Number of minimum values to find
    #
    #
    # **Returns**
    #
    # Output value
    #
    # _Optionals_
    #
    # *x* : Int32? - Horizontal position of minimum
    #
    # *y* : Int32? - Vertical position of minimum
    #
    # *out_array* : Array(Float64)? - Array of output values
    #
    # *x_array* : Array(Int32)? - Array of horizontal positions
    #
    # *y_array* : Array(Int32)? - Array of vertical positions
    #
    def min(**kwargs)
      options = Optional.new(**kwargs)
      options["x"] = true
      options["y"] = true
      options["out_array"] = true
      options["x_array"] = true
      options["y_array"] = true

      results = self.call("min", options).as(Array(Type))
      final_result = results.first.as(Type).as_f64

      opts = results[1]?.try &.as_h

      x = ((o = opts) && (val = o["x"]?)) ? val.as_i32 : nil
      y = ((o = opts) && (val = o["y"]?)) ? val.as_i32 : nil
      out_array = ((o = opts) && (val = o["out_array"]?)) ? val.as_a64 : nil
      x_array = ((o = opts) && (val = o["x_array"]?)) ? val.as_a32 : nil
      y_array = ((o = opts) && (val = o["y_array"]?)) ? val.as_a32 : nil
      {final_result, x, y, out_array, x_array, y_array}
    end

    # Morphology operation
    #
    # ```
    # # out_ = in.morph(mask, morph)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *mask* : Image - Input matrix image
    #
    # *morph* : Enums::OperationMorphology - Morphological operation to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def morph(mask : Image, morph : Enums::OperationMorphology)
      self.call("morph", mask, morph).as(Type).as_image
    end

    # Mosaic two images
    #
    # ```
    # # out_, dx0, dy0, scale1, angle1, dy1, dx1 = ref.mosaic(sec, direction, xref, yref, xsec, ysec, {hwindow: Int32, harea: Int32, mblend: Int32, bandno: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sec* : Image - Secondary image
    #
    # *direction* : Enums::Direction - Horizontal or vertical mosaic
    #
    # *xref* : Int32 - Position of reference tie-point
    #
    # *yref* : Int32 - Position of reference tie-point
    #
    # *xsec* : Int32 - Position of secondary tie-point
    #
    # *ysec* : Int32 - Position of secondary tie-point
    #
    # _Optionals_
    #
    # *hwindow* : Int32 - Half window size
    #
    # *harea* : Int32 - Half area size
    #
    # *mblend* : Int32 - Maximum blend size
    #
    # *bandno* : Int32 - Band to search for features on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *dx0* : Int32? - Detected integer offset
    #
    # *dy0* : Int32? - Detected integer offset
    #
    # *scale1* : Float64? - Detected scale
    #
    # *angle1* : Float64? - Detected rotation
    #
    # *dy1* : Float64? - Detected first-order displacement
    #
    # *dx1* : Float64? - Detected first-order displacement
    #
    def mosaic(sec : Image, direction : Enums::Direction, xref : Int32, yref : Int32, xsec : Int32, ysec : Int32, **kwargs)
      options = Optional.new(**kwargs)
      options["dx0"] = true
      options["dy0"] = true
      options["scale1"] = true
      options["angle1"] = true
      options["dy1"] = true
      options["dx1"] = true

      results = self.call("mosaic", options, sec, direction, xref, yref, xsec, ysec).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      dx0 = ((o = opts) && (val = o["dx0"]?)) ? val.as_i32 : nil
      dy0 = ((o = opts) && (val = o["dy0"]?)) ? val.as_i32 : nil
      scale1 = ((o = opts) && (val = o["scale1"]?)) ? val.as_f64 : nil
      angle1 = ((o = opts) && (val = o["angle1"]?)) ? val.as_f64 : nil
      dy1 = ((o = opts) && (val = o["dy1"]?)) ? val.as_f64 : nil
      dx1 = ((o = opts) && (val = o["dx1"]?)) ? val.as_f64 : nil
      {final_result, dx0, dy0, scale1, angle1, dy1, dx1}
    end

    # First-order mosaic of two images
    #
    # ```
    # # out_ = ref.mosaic1(sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, {hwindow: Int32, harea: Int32, search: Bool, interpolate: Interpolate, mblend: Int32, bandno: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *sec* : Image - Secondary image
    #
    # *direction* : Enums::Direction - Horizontal or vertical mosaic
    #
    # *xr1* : Int32 - Position of first reference tie-point
    #
    # *yr1* : Int32 - Position of first reference tie-point
    #
    # *xs1* : Int32 - Position of first secondary tie-point
    #
    # *ys1* : Int32 - Position of first secondary tie-point
    #
    # *xr2* : Int32 - Position of second reference tie-point
    #
    # *yr2* : Int32 - Position of second reference tie-point
    #
    # *xs2* : Int32 - Position of second secondary tie-point
    #
    # *ys2* : Int32 - Position of second secondary tie-point
    #
    # _Optionals_
    #
    # *hwindow* : Int32 - Half window size
    #
    # *harea* : Int32 - Half area size
    #
    # *search* : Bool - Search to improve tie-points
    #
    # *interpolate* : Interpolate - Interpolate pixels with this
    #
    # *mblend* : Int32 - Maximum blend size
    #
    # *bandno* : Int32 - Band to search for features on
    #
    #
    # **Returns**
    #
    # Output image
    #
    def mosaic1(sec : Image, direction : Enums::Direction, xr1 : Int32, yr1 : Int32, xs1 : Int32, ys1 : Int32, xr2 : Int32, yr2 : Int32, xs2 : Int32, ys2 : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("mosaic1", options, sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2).as(Type).as_image
    end

    # Pick most-significant byte from an image
    #
    # ```
    # # out_ = in.msb({band: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *band* : Int32 - Band to msb
    #
    #
    # **Returns**
    #
    # Output image
    #
    def msb(**kwargs)
      options = Optional.new(**kwargs)

      self.call("msb", options).as(Type).as_image
    end

    # Multiply two images
    #
    # ```
    # # out_ = left.multiply(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    #
    # **Returns**
    #
    # Output image
    #
    def multiply(right : Image)
      self.call("multiply", right).as(Type).as_image
    end

    # Load an openexr image
    #
    # ```
    # # out_, flags = Vips::Image.openexrload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.openexrload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("openexrload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load file with openslide
    #
    # ```
    # # out_, flags = Vips::Image.openslideload(filename, {attach_associated: Bool, level: Int32, autocrop: Bool, associated: String, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *attach_associated* : Bool - Attach all associated images
    #
    # *level* : Int32 - Load this level from the file
    #
    # *autocrop* : Bool - Crop to image bounds
    #
    # *associated* : String - Load this associated image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.openslideload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("openslideload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load source with openslide
    #
    # ```
    # # out_, flags = Vips::Image.openslideload_source(source, {attach_associated: Bool, level: Int32, autocrop: Bool, associated: String, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *attach_associated* : Bool - Attach all associated images
    #
    # *level* : Int32 - Load this level from the file
    #
    # *autocrop* : Bool - Crop to image bounds
    #
    # *associated* : String - Load this associated image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.openslideload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("openslideload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load stream with openslide
    #
    # ```
    # # out_, flags = Vips::Image.openslideload_stream(stream, {attach_associated: Bool, level: Int32, autocrop: Bool, associated: String, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *attach_associated* : Bool - Attach all associated images
    #
    # *level* : Int32 - Load this level from the file
    #
    # *autocrop* : Bool - Crop to image bounds
    #
    # *associated* : String - Load this associated image
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.openslideload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      openslideload_source(source, **kwargs)
    end

    # Save image in pbm format
    #
    # ```
    # in.pbmsave_target(target, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def pbmsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("pbmsave_target", options, target)
    end

    # Save image in pbm format
    #
    # ```
    # in.pbmsave_stream(stream, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def pbmsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      pbmsave_target(target, **kwargs)
    end

    # Load pdf from file
    #
    # ```
    # # out_, flags = Vips::Image.pdfload(filename, {page: Int32, n: Int32, dpi: Float64, scale: Float64, background: Array(Float64), memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *background* : Array(Float64) - Background value
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.pdfload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("pdfload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load pdf from buffer
    #
    # ```
    # # out_, flags = Vips::Image.pdfload_buffer(buffer, {page: Int32, n: Int32, dpi: Float64, scale: Float64, background: Array(Float64), memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *background* : Array(Float64) - Background value
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.pdfload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("pdfload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load pdf from source
    #
    # ```
    # # out_, flags = Vips::Image.pdfload_source(source, {page: Int32, n: Int32, dpi: Float64, scale: Float64, background: Array(Float64), memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *background* : Array(Float64) - Background value
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.pdfload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("pdfload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load pdf from stream
    #
    # ```
    # # out_, flags = Vips::Image.pdfload_stream(stream, {page: Int32, n: Int32, dpi: Float64, scale: Float64, background: Array(Float64), memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *background* : Array(Float64) - Background value
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.pdfload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      pdfload_source(source, **kwargs)
    end

    # Find threshold for percent of pixels
    #
    # ```
    # # threshold = in.percent(percent)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *percent* : Float64 - Percent of pixels
    #
    #
    # **Returns**
    #
    # Threshold above which lie percent of pixels
    #
    def percent(percent : Float64)
      self.call("percent", percent).as(Type).as_i32
    end

    # Make a perlin noise image
    #
    # ```
    # # out_ = Vips::Image.perlin(width, height, {cell_size: Int32, uchar: Bool, seed: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *cell_size* : Int32 - Size of Perlin cells
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *seed* : Int32 - Random number seed
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.perlin(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("perlin", options, width, height).as(Type).as_image
    end

    # Save image in pfm format
    #
    # ```
    # in.pfmsave_target(target, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def pfmsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("pfmsave_target", options, target)
    end

    # Save image in pfm format
    #
    # ```
    # in.pfmsave_stream(stream, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def pfmsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      pfmsave_target(target, **kwargs)
    end

    # Save image in pgm format
    #
    # ```
    # in.pgmsave_target(target, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def pgmsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("pgmsave_target", options, target)
    end

    # Save image in pgm format
    #
    # ```
    # in.pgmsave_stream(stream, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def pgmsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      pgmsave_target(target, **kwargs)
    end

    # Calculate phase correlation
    #
    # ```
    # # out_ = in.phasecor(in2)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *in2* : Image - Second input image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def phasecor(in2 : Image)
      self.call("phasecor", in2).as(Type).as_image
    end

    # Load png from file
    #
    # ```
    # # out_, flags = Vips::Image.pngload(filename, {unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *unlimited* : Bool - Remove all denial of service limits
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.pngload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("pngload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load png from buffer
    #
    # ```
    # # out_, flags = Vips::Image.pngload_buffer(buffer, {unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *unlimited* : Bool - Remove all denial of service limits
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.pngload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("pngload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load png from source
    #
    # ```
    # # out_, flags = Vips::Image.pngload_source(source, {unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *unlimited* : Bool - Remove all denial of service limits
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.pngload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("pngload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load png from stream
    #
    # ```
    # # out_, flags = Vips::Image.pngload_stream(stream, {unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *unlimited* : Bool - Remove all denial of service limits
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.pngload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      pngload_source(source, **kwargs)
    end

    # Save image to png file
    #
    # ```
    # in.pngsave(filename, {compression: Int32, interlace: Bool, profile: String, filter: Enums::ForeignPngFilter, palette: Bool, q: Int32, dither: Float64, bitdepth: Int32, effort: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *compression* : Int32 - Compression factor
    #
    # *interlace* : Bool - Interlace image
    #
    # *profile* : String - ICC profile to embed
    #
    # *filter* : Enums::ForeignPngFilter - libpng row filter flag(s)
    #
    # *palette* : Bool - Quantise to 8bpp palette
    #
    # *q* : Int32 - Quantisation quality
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *bitdepth* : Int32 - Write as a 1, 2, 4, 8 or 16 bit image
    #
    # *effort* : Int32 - Quantisation CPU effort
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def pngsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("pngsave", options, filename)
    end

    # Save image to png buffer
    #
    # ```
    # # buffer = in.pngsave_buffer({compression: Int32, interlace: Bool, profile: String, filter: Enums::ForeignPngFilter, palette: Bool, q: Int32, dither: Float64, bitdepth: Int32, effort: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *compression* : Int32 - Compression factor
    #
    # *interlace* : Bool - Interlace image
    #
    # *profile* : String - ICC profile to embed
    #
    # *filter* : Enums::ForeignPngFilter - libpng row filter flag(s)
    #
    # *palette* : Bool - Quantise to 8bpp palette
    #
    # *q* : Int32 - Quantisation quality
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *bitdepth* : Int32 - Write as a 1, 2, 4, 8 or 16 bit image
    #
    # *effort* : Int32 - Quantisation CPU effort
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def pngsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("pngsave_buffer", options).as(Type).as_bytes
    end

    # Save image to target as png
    #
    # ```
    # in.pngsave_target(target, {compression: Int32, interlace: Bool, profile: String, filter: Enums::ForeignPngFilter, palette: Bool, q: Int32, dither: Float64, bitdepth: Int32, effort: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *compression* : Int32 - Compression factor
    #
    # *interlace* : Bool - Interlace image
    #
    # *profile* : String - ICC profile to embed
    #
    # *filter* : Enums::ForeignPngFilter - libpng row filter flag(s)
    #
    # *palette* : Bool - Quantise to 8bpp palette
    #
    # *q* : Int32 - Quantisation quality
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *bitdepth* : Int32 - Write as a 1, 2, 4, 8 or 16 bit image
    #
    # *effort* : Int32 - Quantisation CPU effort
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def pngsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("pngsave_target", options, target)
    end

    # Save image to stream as png
    #
    # ```
    # in.pngsave_stream(stream, {compression: Int32, interlace: Bool, profile: String, filter: Enums::ForeignPngFilter, palette: Bool, q: Int32, dither: Float64, bitdepth: Int32, effort: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *compression* : Int32 - Compression factor
    #
    # *interlace* : Bool - Interlace image
    #
    # *profile* : String - ICC profile to embed
    #
    # *filter* : Enums::ForeignPngFilter - libpng row filter flag(s)
    #
    # *palette* : Bool - Quantise to 8bpp palette
    #
    # *q* : Int32 - Quantisation quality
    #
    # *dither* : Float64 - Amount of dithering
    #
    # *bitdepth* : Int32 - Write as a 1, 2, 4, 8 or 16 bit image
    #
    # *effort* : Int32 - Quantisation CPU effort
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def pngsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      pngsave_target(target, **kwargs)
    end

    # Load ppm from file
    #
    # ```
    # # out_, flags = Vips::Image.ppmload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.ppmload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("ppmload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load ppm base class
    #
    # ```
    # # out_, flags = Vips::Image.ppmload_source(source, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.ppmload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("ppmload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load ppm base class
    #
    # ```
    # # out_, flags = Vips::Image.ppmload_stream(stream, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.ppmload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      ppmload_source(source, **kwargs)
    end

    # Save image to ppm file
    #
    # ```
    # in.ppmsave(filename, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def ppmsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("ppmsave", options, filename)
    end

    # Save to ppm
    #
    # ```
    # in.ppmsave_target(target, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def ppmsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("ppmsave_target", options, target)
    end

    # Save to ppm
    #
    # ```
    # in.ppmsave_stream(stream, {format: Enums::ForeignPpmFormat, ascii: Bool, bitdepth: Int32, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *format* : Enums::ForeignPpmFormat - Format to save in
    #
    # *ascii* : Bool - save as ascii
    #
    # *bitdepth* : Int32 - set to 1 to write as a 1 bit image
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def ppmsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      ppmsave_target(target, **kwargs)
    end

    # Premultiply image alpha
    #
    # ```
    # # out_ = in.premultiply({max_alpha: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *max_alpha* : Float64 - Maximum value of alpha channel
    #
    #
    # **Returns**
    #
    # Output image
    #
    def premultiply(**kwargs)
      options = Optional.new(**kwargs)

      self.call("premultiply", options).as(Type).as_image
    end

    # Find image profiles
    #
    # ```
    # # output   = in.profile()
    # ```
    #
    #
    # **Returns**
    #
    # First non-zero pixel in column
    #
    # First non-zero pixel in row
    #
    def profile
      results = self.call("profile").as(Array(Type))

      {results[0].as_image, results[1].as_image}
    end

    # Load named icc profile
    #
    # ```
    # # profile = Vips::Image.profile_load(name)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *name* : String - Profile name
    #
    #
    # **Returns**
    #
    # Loaded profile
    #
    def self.profile_load(name : String)
      Operation.call("profile_load", name).as(Type).as_bytes
    end

    # Find image projections
    #
    # ```
    # # output   = in.project()
    # ```
    #
    #
    # **Returns**
    #
    # Sums of columns
    #
    # Sums of rows
    #
    def project
      results = self.call("project").as(Array(Type))

      {results[0].as_image, results[1].as_image}
    end

    # Resample an image with a quadratic transform
    #
    # ```
    # # out_ = in.quadratic(coeff, {interpolate: Interpolate})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *coeff* : Image - Coefficient matrix
    #
    # _Optionals_
    #
    # *interpolate* : Interpolate - Interpolate values with this
    #
    #
    # **Returns**
    #
    # Output image
    #
    def quadratic(coeff : Image, **kwargs)
      options = Optional.new(**kwargs)

      self.call("quadratic", options, coeff).as(Type).as_image
    end

    # Unpack radiance coding to float rgb
    #
    # ```
    # # out_ = in.rad2float()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def rad2float
      self.call("rad2float").as(Type).as_image
    end

    # Load a radiance image from a file
    #
    # ```
    # # out_, flags = Vips::Image.radload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.radload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("radload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load rad from buffer
    #
    # ```
    # # out_, flags = Vips::Image.radload_buffer(buffer, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.radload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("radload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load rad from source
    #
    # ```
    # # out_, flags = Vips::Image.radload_source(source, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.radload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("radload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load rad from stream
    #
    # ```
    # # out_, flags = Vips::Image.radload_stream(stream, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.radload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      radload_source(source, **kwargs)
    end

    # Save image to radiance file
    #
    # ```
    # in.radsave(filename, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def radsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("radsave", options, filename)
    end

    # Save image to radiance buffer
    #
    # ```
    # # buffer = in.radsave_buffer({strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def radsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("radsave_buffer", options).as(Type).as_bytes
    end

    # Save image to radiance target
    #
    # ```
    # in.radsave_target(target, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def radsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("radsave_target", options, target)
    end

    # Save image to radiance stream
    #
    # ```
    # in.radsave_stream(stream, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def radsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      radsave_target(target, **kwargs)
    end

    # Rank filter
    #
    # ```
    # # out_ = in.rank(width, height, index)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Window width in pixels
    #
    # *height* : Int32 - Window height in pixels
    #
    # *index* : Int32 - Select pixel at index
    #
    #
    # **Returns**
    #
    # Output image
    #
    def rank(width : Int32, height : Int32, index : Int32)
      self.call("rank", width, height, index).as(Type).as_image
    end

    # Load raw data from a file
    #
    # ```
    # # out_, flags = Vips::Image.rawload(filename, width, height, bands, {offset: UInt32, format: Enums::BandFormat, interpretation: Enums::Interpretation, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # *bands* : Int32 - Number of bands in image
    #
    # _Optionals_
    #
    # *offset* : UInt32 - Offset in bytes from start of file
    #
    # *format* : Enums::BandFormat - Pixel format in image
    #
    # *interpretation* : Enums::Interpretation - Pixel interpretation
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.rawload(filename : String, width : Int32, height : Int32, bands : Int32, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("rawload", options, filename, width, height, bands).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Save image to raw file
    #
    # ```
    # in.rawsave(filename, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def rawsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("rawsave", options, filename)
    end

    # Write raw image to file descriptor
    #
    # ```
    # in.rawsave_fd(fd, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *fd* : Int32 - File descriptor to write to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def rawsave_fd(fd : Int32, **kwargs)
      options = Optional.new(**kwargs)
      self.call("rawsave_fd", options, fd)
    end

    # Linear recombination with matrix
    #
    # ```
    # # out_ = in.recomb(m)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *m* : Image - matrix of coefficients
    #
    #
    # **Returns**
    #
    # Output image
    #
    def recomb(m : Image)
      self.call("recomb", m).as(Type).as_image
    end

    # Reduce an image
    #
    # ```
    # # out_ = in.reduce(hshrink, vshrink, {kernel: Enums::Kernel})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *hshrink* : Float64 - Horizontal shrink factor
    #
    # *vshrink* : Float64 - Vertical shrink factor
    #
    # _Optionals_
    #
    # *kernel* : Enums::Kernel - Resampling kernel
    #
    #
    # **Returns**
    #
    # Output image
    #
    def reduce(hshrink : Float64, vshrink : Float64, **kwargs)
      options = Optional.new(**kwargs)

      self.call("reduce", options, hshrink, vshrink).as(Type).as_image
    end

    # Shrink an image horizontally
    #
    # ```
    # # out_ = in.reduceh(hshrink, {kernel: Enums::Kernel})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *hshrink* : Float64 - Horizontal shrink factor
    #
    # _Optionals_
    #
    # *kernel* : Enums::Kernel - Resampling kernel
    #
    #
    # **Returns**
    #
    # Output image
    #
    def reduceh(hshrink : Float64, **kwargs)
      options = Optional.new(**kwargs)

      self.call("reduceh", options, hshrink).as(Type).as_image
    end

    # Shrink an image vertically
    #
    # ```
    # # out_ = in.reducev(vshrink, {kernel: Enums::Kernel})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *vshrink* : Float64 - Vertical shrink factor
    #
    # _Optionals_
    #
    # *kernel* : Enums::Kernel - Resampling kernel
    #
    #
    # **Returns**
    #
    # Output image
    #
    def reducev(vshrink : Float64, **kwargs)
      options = Optional.new(**kwargs)

      self.call("reducev", options, vshrink).as(Type).as_image
    end

    # Relational operation on two images
    #
    # ```
    # # out_ = left.relational(right, relational)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    # *relational* : Enums::OperationRelational - relational to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def relational(right : Image, relational : Enums::OperationRelational)
      self.call("relational", right, relational).as(Type).as_image
    end

    # Relational operations against a constant
    #
    # ```
    # # out_ = in.relational_const(relational, c)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *relational* : Enums::OperationRelational - relational to perform
    #
    # *c* : Array(Float64) - Array of constants
    #
    #
    # **Returns**
    #
    # Output image
    #
    def relational_const(relational : Enums::OperationRelational, c : Array(Float64))
      self.call("relational_const", relational, c).as(Type).as_image
    end

    # Remainder after integer division of two images
    #
    # ```
    # # out_ = left.remainder(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    #
    # **Returns**
    #
    # Output image
    #
    def remainder(right : Image)
      self.call("remainder", right).as(Type).as_image
    end

    # Remainder after integer division of an image and a constant
    #
    # ```
    # # out_ = in.remainder_const(c)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *c* : Array(Float64) - Array of constants
    #
    #
    # **Returns**
    #
    # Output image
    #
    def remainder_const(c : Array(Float64))
      self.call("remainder_const", c).as(Type).as_image
    end

    # Replicate an image
    #
    # ```
    # # out_ = in.replicate(across, down)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *across* : Int32 - Repeat this many times horizontally
    #
    # *down* : Int32 - Repeat this many times vertically
    #
    #
    # **Returns**
    #
    # Output image
    #
    def replicate(across : Int32, down : Int32)
      self.call("replicate", across, down).as(Type).as_image
    end

    # Resize an image
    #
    # ```
    # # out_ = in.resize(scale, {kernel: Enums::Kernel, vscale: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *scale* : Float64 - Scale image by this factor
    #
    # _Optionals_
    #
    # *kernel* : Enums::Kernel - Resampling kernel
    #
    # *vscale* : Float64 - Vertical scale image by this factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def resize(scale : Float64, **kwargs)
      options = Optional.new(**kwargs)

      self.call("resize", options, scale).as(Type).as_image
    end

    # Rotate an image
    #
    # ```
    # # out_ = in.rot(angle)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *angle* : Enums::Angle - Angle to rotate image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def rot(angle : Enums::Angle)
      self.call("rot", angle).as(Type).as_image
    end

    # Rotate an image
    #
    # ```
    # # out_ = in.rot45({angle: Enums::Angle45})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *angle* : Enums::Angle45 - Angle to rotate image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def rot45(**kwargs)
      options = Optional.new(**kwargs)

      self.call("rot45", options).as(Type).as_image
    end

    # Rotate an image by a number of degrees
    #
    # ```
    # # out_ = in.rotate(angle, {interpolate: Interpolate, background: Array(Float64), odx: Float64, ody: Float64, idx: Float64, idy: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *angle* : Float64 - Rotate anticlockwise by this many degrees
    #
    # _Optionals_
    #
    # *interpolate* : Interpolate - Interpolate pixels with this
    #
    # *background* : Array(Float64) - Background value
    #
    # *odx* : Float64 - Horizontal output displacement
    #
    # *ody* : Float64 - Vertical output displacement
    #
    # *idx* : Float64 - Horizontal input displacement
    #
    # *idy* : Float64 - Vertical input displacement
    #
    #
    # **Returns**
    #
    # Output image
    #
    def rotate(angle : Float64, **kwargs)
      options = Optional.new(**kwargs)

      self.call("rotate", options, angle).as(Type).as_image
    end

    # Perform a round function on an image
    #
    # ```
    # # out_ = in.round(round)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *round* : Enums::OperationRound - rounding operation to perform
    #
    #
    # **Returns**
    #
    # Output image
    #
    def round(round : Enums::OperationRound)
      self.call("round", round).as(Type).as_image
    end

    # Convert scrgb to bw
    #
    # ```
    # # out_ = in.scrgb2bw({depth: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *depth* : Int32 - Output device space depth in bits
    #
    #
    # **Returns**
    #
    # Output image
    #
    def scrgb2bw(**kwargs)
      options = Optional.new(**kwargs)

      self.call("scrgb2bw", options).as(Type).as_image
    end

    # Convert an scrgb image to srgb
    #
    # ```
    # # out_ = in.scrgb2srgb({depth: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *depth* : Int32 - Output device space depth in bits
    #
    #
    # **Returns**
    #
    # Output image
    #
    def scrgb2srgb(**kwargs)
      options = Optional.new(**kwargs)

      self.call("scrgb2srgb", options).as(Type).as_image
    end

    # Transform scrgb to xyz
    #
    # ```
    # # out_ = in.scrgb2xyz()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def scrgb2xyz
      self.call("scrgb2xyz").as(Type).as_image
    end

    # Check sequential access
    #
    # ```
    # # out_ = in.sequential({tile_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    #
    # **Returns**
    #
    # Output image
    #
    def sequential(**kwargs)
      options = Optional.new(**kwargs)

      self.call("sequential", options).as(Type).as_image
    end

    # Unsharp masking for print
    #
    # ```
    # # out_ = in.sharpen({sigma: Float64, x1: Float64, y2: Float64, y3: Float64, m1: Float64, m2: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *sigma* : Float64 - Sigma of Gaussian
    #
    # *x1* : Float64 - Flat/jaggy threshold
    #
    # *y2* : Float64 - Maximum brightening
    #
    # *y3* : Float64 - Maximum darkening
    #
    # *m1* : Float64 - Slope for flat areas
    #
    # *m2* : Float64 - Slope for jaggy areas
    #
    #
    # **Returns**
    #
    # Output image
    #
    def sharpen(**kwargs)
      options = Optional.new(**kwargs)

      self.call("sharpen", options).as(Type).as_image
    end

    # Shrink an image
    #
    # ```
    # # out_ = in.shrink(hshrink, vshrink)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *hshrink* : Float64 - Horizontal shrink factor
    #
    # *vshrink* : Float64 - Vertical shrink factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def shrink(hshrink : Float64, vshrink : Float64)
      self.call("shrink", hshrink, vshrink).as(Type).as_image
    end

    # Shrink an image horizontally
    #
    # ```
    # # out_ = in.shrinkh(hshrink)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *hshrink* : Int32 - Horizontal shrink factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def shrinkh(hshrink : Int32)
      self.call("shrinkh", hshrink).as(Type).as_image
    end

    # Shrink an image vertically
    #
    # ```
    # # out_ = in.shrinkv(vshrink)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *vshrink* : Int32 - Vertical shrink factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def shrinkv(vshrink : Int32)
      self.call("shrinkv", vshrink).as(Type).as_image
    end

    # Unit vector of pixel
    #
    # ```
    # # out_ = in.sign()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def sign
      self.call("sign").as(Type).as_image
    end

    # Similarity transform of an image
    #
    # ```
    # # out_ = in.similarity({scale: Float64, angle: Float64, interpolate: Interpolate, background: Array(Float64), odx: Float64, ody: Float64, idx: Float64, idy: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *scale* : Float64 - Scale by this factor
    #
    # *angle* : Float64 - Rotate anticlockwise by this many degrees
    #
    # *interpolate* : Interpolate - Interpolate pixels with this
    #
    # *background* : Array(Float64) - Background value
    #
    # *odx* : Float64 - Horizontal output displacement
    #
    # *ody* : Float64 - Vertical output displacement
    #
    # *idx* : Float64 - Horizontal input displacement
    #
    # *idy* : Float64 - Vertical input displacement
    #
    #
    # **Returns**
    #
    # Output image
    #
    def similarity(**kwargs)
      options = Optional.new(**kwargs)

      self.call("similarity", options).as(Type).as_image
    end

    # Make a 2d sine wave
    #
    # ```
    # # out_ = Vips::Image.sines(width, height, {uchar: Bool, hfreq: Float64, vfreq: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    # *hfreq* : Float64 - Horizontal spatial frequency
    #
    # *vfreq* : Float64 - Vertical spatial frequency
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.sines(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("sines", options, width, height).as(Type).as_image
    end

    # Extract an area from an image
    #
    # ```
    # # out_ = input.smartcrop(width, height, {interesting: Enums::Interesting})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Width of extract area
    #
    # *height* : Int32 - Height of extract area
    #
    # _Optionals_
    #
    # *interesting* : Enums::Interesting - How to measure interestingness
    #
    #
    # **Returns**
    #
    # Output image
    #
    def smartcrop(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("smartcrop", options, width, height).as(Type).as_image
    end

    # Sobel edge detector
    #
    # ```
    # # out_ = in.sobel()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def sobel
      self.call("sobel").as(Type).as_image
    end

    # Spatial correlation
    #
    # ```
    # # out_ = in.spcor(ref)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *ref* : Image - Input reference image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def spcor(ref : Image)
      self.call("spcor", ref).as(Type).as_image
    end

    # Make displayable power spectrum
    #
    # ```
    # # out_ = in.spectrum()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def spectrum
      self.call("spectrum").as(Type).as_image
    end

    # Transform srgb to hsv
    #
    # ```
    # # out_ = in.srgb2hsv()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def srgb2hsv
      self.call("srgb2hsv").as(Type).as_image
    end

    # Convert an srgb image to scrgb
    #
    # ```
    # # out_ = in.srgb2scrgb()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def srgb2scrgb
      self.call("srgb2scrgb").as(Type).as_image
    end

    # Find many image stats
    #
    # ```
    # # out_ = in.stats()
    # ```
    #
    #
    # **Returns**
    #
    # Output array of statistics
    #
    def stats
      self.call("stats").as(Type).as_image
    end

    # Statistical difference
    #
    # ```
    # # out_ = in.stdif(width, height, {s0: Float64, b: Float64, m0: Float64, a: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Window width in pixels
    #
    # *height* : Int32 - Window height in pixels
    #
    # _Optionals_
    #
    # *s0* : Float64 - New deviation
    #
    # *b* : Float64 - Weight of new deviation
    #
    # *m0* : Float64 - New mean
    #
    # *a* : Float64 - Weight of new mean
    #
    #
    # **Returns**
    #
    # Output image
    #
    def stdif(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("stdif", options, width, height).as(Type).as_image
    end

    # Subsample an image
    #
    # ```
    # # out_ = input.subsample(xfac, yfac, {point: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *xfac* : Int32 - Horizontal subsample factor
    #
    # *yfac* : Int32 - Vertical subsample factor
    #
    # _Optionals_
    #
    # *point* : Bool - Point sample
    #
    #
    # **Returns**
    #
    # Output image
    #
    def subsample(xfac : Int32, yfac : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("subsample", options, xfac, yfac).as(Type).as_image
    end

    # Subtract two images
    #
    # ```
    # # out_ = left.subtract(right)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *right* : Image - Right-hand image argument
    #
    #
    # **Returns**
    #
    # Output image
    #
    def subtract(right : Image)
      self.call("subtract", right).as(Type).as_image
    end

    # Sum an array of images
    #
    # ```
    # # out_ = Vips::Image.sum(in_)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *in* : Array(Image) - Array of input images
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.sum(*in_ : Image)
      Operation.call("sum", in_).as(Type).as_image
    end

    # Load svg with rsvg
    #
    # ```
    # # out_, flags = Vips::Image.svgload(filename, {dpi: Float64, scale: Float64, unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *unlimited* : Bool - Allow SVG of any size
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.svgload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("svgload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load svg with rsvg
    #
    # ```
    # # out_, flags = Vips::Image.svgload_buffer(buffer, {dpi: Float64, scale: Float64, unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *unlimited* : Bool - Allow SVG of any size
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.svgload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("svgload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load svg from source
    #
    # ```
    # # out_, flags = Vips::Image.svgload_source(source, {dpi: Float64, scale: Float64, unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *unlimited* : Bool - Allow SVG of any size
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.svgload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("svgload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load svg from stream
    #
    # ```
    # # out_, flags = Vips::Image.svgload_stream(stream, {dpi: Float64, scale: Float64, unlimited: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *dpi* : Float64 - Render at this DPI
    #
    # *scale* : Float64 - Scale output by this factor
    #
    # *unlimited* : Bool - Allow SVG of any size
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.svgload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      svgload_source(source, **kwargs)
    end

    # Find the index of the first non-zero pixel in tests
    #
    # ```
    # # out_ = Vips::Image.switch(tests)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *tests* : Array(Image) - Table of images to test
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.switch(*tests : Image)
      Operation.call("switch", tests).as(Type).as_image
    end

    # Run an external command
    #
    # ```
    # , out_, log = Vips::Image.system(cmd_format, {in_: Array(Image), out_format: String, in_format: String})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *cmd_format* : String - Command to run
    #
    # _Optionals_
    #
    # *in* : Array(Image) - Array of input images
    #
    # *out_format* : String - Format for output filename
    #
    # *in_format* : String - Format for input filename
    #
    #
    # **Returns**
    #
    # _Optionals_
    #
    # *out* : Image? - Output image
    #
    # *log* : String? - Command log
    #
    def self.system(cmd_format : String, **kwargs)
      options = Optional.new(**kwargs)
      options["out"] = true
      options["log"] = true

      optsOperation.call("system", options, cmd_format).as(Type).as_h
    end

    # Make a text image
    #
    # ```
    # # out_, autofit_dpi = Vips::Image.text(text, {font: String, width: Int32, height: Int32, align: Enums::Align, rgba: Bool, dpi: Int32, justify: Bool, spacing: Int32, fontfile: String})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *text* : String - Text to render
    #
    # _Optionals_
    #
    # *font* : String - Font to render with
    #
    # *width* : Int32 - Maximum image width in pixels
    #
    # *height* : Int32 - Maximum image height in pixels
    #
    # *align* : Enums::Align - Align on the low, centre or high edge
    #
    # *rgba* : Bool - Enable RGBA output
    #
    # *dpi* : Int32 - DPI to render at
    #
    # *justify* : Bool - Justify lines
    #
    # *spacing* : Int32 - Line spacing
    #
    # *fontfile* : String - Load this font file
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *autofit_dpi* : Int32? - DPI selected by autofit
    #
    def self.text(text : String, **kwargs)
      options = Optional.new(**kwargs)
      options["autofit_dpi"] = true

      results = Operation.call("text", options, text).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      autofit_dpi = ((o = opts) && (val = o["autofit_dpi"]?)) ? val.as_i32 : nil
      {final_result, autofit_dpi}
    end

    # Generate thumbnail from file
    #
    # ```
    # # out_ = Vips::Image.thumbnail(filename, width, {height: Int32, size: Enums::Size, no_rotate: Bool, crop: Enums::Interesting, linear: Bool, import_profile: String, export_profile: String, intent: Enums::Intent})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to read from
    #
    # *width* : Int32 - Size to this width
    #
    # _Optionals_
    #
    # *height* : Int32 - Size to this height
    #
    # *size* : Enums::Size - Only upsize, only downsize, or both
    #
    # *no_rotate* : Bool - Don't use orientation tags to rotate image upright
    #
    # *crop* : Enums::Interesting - Reduce to fill target rectangle, then crop
    #
    # *linear* : Bool - Reduce in linear light
    #
    # *import_profile* : String - Fallback import profile
    #
    # *export_profile* : String - Fallback export profile
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.thumbnail(filename : String, width : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("thumbnail", options, filename, width).as(Type).as_image
    end

    # Generate thumbnail from buffer
    #
    # ```
    # # out_ = Vips::Image.thumbnail_buffer(buffer, width, {option_string: String, height: Int32, size: Enums::Size, no_rotate: Bool, crop: Enums::Interesting, linear: Bool, import_profile: String, export_profile: String, intent: Enums::Intent})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # *width* : Int32 - Size to this width
    #
    # _Optionals_
    #
    # *option_string* : String - Options that are passed on to the underlying loader
    #
    # *height* : Int32 - Size to this height
    #
    # *size* : Enums::Size - Only upsize, only downsize, or both
    #
    # *no_rotate* : Bool - Don't use orientation tags to rotate image upright
    #
    # *crop* : Enums::Interesting - Reduce to fill target rectangle, then crop
    #
    # *linear* : Bool - Reduce in linear light
    #
    # *import_profile* : String - Fallback import profile
    #
    # *export_profile* : String - Fallback export profile
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.thumbnail_buffer(buffer : Bytes, width : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("thumbnail_buffer", options, buffer, width).as(Type).as_image
    end

    # Generate thumbnail from image
    #
    # ```
    # # out_ = in.thumbnail_image(width, {height: Int32, size: Enums::Size, no_rotate: Bool, crop: Enums::Interesting, linear: Bool, import_profile: String, export_profile: String, intent: Enums::Intent})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Size to this width
    #
    # _Optionals_
    #
    # *height* : Int32 - Size to this height
    #
    # *size* : Enums::Size - Only upsize, only downsize, or both
    #
    # *no_rotate* : Bool - Don't use orientation tags to rotate image upright
    #
    # *crop* : Enums::Interesting - Reduce to fill target rectangle, then crop
    #
    # *linear* : Bool - Reduce in linear light
    #
    # *import_profile* : String - Fallback import profile
    #
    # *export_profile* : String - Fallback export profile
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    #
    # **Returns**
    #
    # Output image
    #
    def thumbnail_image(width : Int32, **kwargs)
      options = Optional.new(**kwargs)

      self.call("thumbnail_image", options, width).as(Type).as_image
    end

    # Generate thumbnail from source
    #
    # ```
    # # out_ = Vips::Image.thumbnail_source(source, width, {option_string: String, height: Int32, size: Enums::Size, no_rotate: Bool, crop: Enums::Interesting, linear: Bool, import_profile: String, export_profile: String, intent: Enums::Intent})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # *width* : Int32 - Size to this width
    #
    # _Optionals_
    #
    # *option_string* : String - Options that are passed on to the underlying loader
    #
    # *height* : Int32 - Size to this height
    #
    # *size* : Enums::Size - Only upsize, only downsize, or both
    #
    # *no_rotate* : Bool - Don't use orientation tags to rotate image upright
    #
    # *crop* : Enums::Interesting - Reduce to fill target rectangle, then crop
    #
    # *linear* : Bool - Reduce in linear light
    #
    # *import_profile* : String - Fallback import profile
    #
    # *export_profile* : String - Fallback export profile
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.thumbnail_source(source : Source, width : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("thumbnail_source", options, source, width).as(Type).as_image
    end

    # Generate thumbnail from stream
    #
    # ```
    # # out_ = Vips::Image.thumbnail_stream(stream, width, {option_string: String, height: Int32, size: Enums::Size, no_rotate: Bool, crop: Enums::Interesting, linear: Bool, import_profile: String, export_profile: String, intent: Enums::Intent})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    #
    # *width : Int32* - Size to this width
    # _Optionals_
    #
    # *option_string* : String - Options that are passed on to the underlying loader
    #
    # *height* : Int32 - Size to this height
    #
    # *size* : Enums::Size - Only upsize, only downsize, or both
    #
    # *no_rotate* : Bool - Don't use orientation tags to rotate image upright
    #
    # *crop* : Enums::Interesting - Reduce to fill target rectangle, then crop
    #
    # *linear* : Bool - Reduce in linear light
    #
    # *import_profile* : String - Fallback import profile
    #
    # *export_profile* : String - Fallback export profile
    #
    # *intent* : Enums::Intent - Rendering intent
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    def self.thumbnail_stream(stream : IO, width : Int32, **kwargs)
      source = SourceStream.new_from_stream(stream)
      thumbnail_source(source, width, **kwargs)
    end

    # Load tiff from file
    #
    # ```
    # # out_, flags = Vips::Image.tiffload(filename, {page: Int32, subifd: Int32, n: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *subifd* : Int32 - Select subifd index
    #
    # *n* : Int32 - Load this many pages
    #
    # *autorotate* : Bool - Rotate image using orientation tag
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.tiffload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("tiffload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load tiff from buffer
    #
    # ```
    # # out_, flags = Vips::Image.tiffload_buffer(buffer, {page: Int32, subifd: Int32, n: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *subifd* : Int32 - Select subifd index
    #
    # *n* : Int32 - Load this many pages
    #
    # *autorotate* : Bool - Rotate image using orientation tag
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.tiffload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("tiffload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load tiff from source
    #
    # ```
    # # out_, flags = Vips::Image.tiffload_source(source, {page: Int32, subifd: Int32, n: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *subifd* : Int32 - Select subifd index
    #
    # *n* : Int32 - Load this many pages
    #
    # *autorotate* : Bool - Rotate image using orientation tag
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.tiffload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("tiffload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load tiff from stream
    #
    # ```
    # # out_, flags = Vips::Image.tiffload_stream(stream, {page: Int32, subifd: Int32, n: Int32, autorotate: Bool, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the image
    #
    # *subifd* : Int32 - Select subifd index
    #
    # *n* : Int32 - Load this many pages
    #
    # *autorotate* : Bool - Rotate image using orientation tag
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.tiffload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      tiffload_source(source, **kwargs)
    end

    # Save image to tiff file
    #
    # ```
    # in.tiffsave(filename, {compression: Enums::ForeignTiffCompression, q: Int32, predictor: Enums::ForeignTiffPredictor, profile: String, tile: Bool, tile_width: Int32, tile_height: Int32, pyramid: Bool, miniswhite: Bool, bitdepth: Int32, resunit: Enums::ForeignTiffResunit, xres: Float64, yres: Float64, bigtiff: Bool, properties: Bool, region_shrink: Enums::RegionShrink, level: Int32, lossless: Bool, depth: Enums::ForeignDzDepth, subifd: Bool, premultiply: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *compression* : Enums::ForeignTiffCompression - Compression for this file
    #
    # *q* : Int32 - Q factor
    #
    # *predictor* : Enums::ForeignTiffPredictor - Compression prediction
    #
    # *profile* : String - ICC profile to embed
    #
    # *tile* : Bool - Write a tiled tiff
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *pyramid* : Bool - Write a pyramidal tiff
    #
    # *miniswhite* : Bool - Use 0 for white in 1-bit images
    #
    # *bitdepth* : Int32 - Write as a 1, 2, 4 or 8 bit image
    #
    # *resunit* : Enums::ForeignTiffResunit - Resolution unit
    #
    # *xres* : Float64 - Horizontal resolution in pixels/mm
    #
    # *yres* : Float64 - Vertical resolution in pixels/mm
    #
    # *bigtiff* : Bool - Write a bigtiff image
    #
    # *properties* : Bool - Write a properties document to IMAGEDESCRIPTION
    #
    # *region_shrink* : Enums::RegionShrink - Method to shrink regions
    #
    # *level* : Int32 - ZSTD compression level
    #
    # *lossless* : Bool - Enable WEBP lossless mode
    #
    # *depth* : Enums::ForeignDzDepth - Pyramid depth
    #
    # *subifd* : Bool - Save pyr layers as sub-IFDs
    #
    # *premultiply* : Bool - Save with premultiplied alpha
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def tiffsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("tiffsave", options, filename)
    end

    # Save image to tiff buffer
    #
    # ```
    # # buffer = in.tiffsave_buffer({compression: Enums::ForeignTiffCompression, q: Int32, predictor: Enums::ForeignTiffPredictor, profile: String, tile: Bool, tile_width: Int32, tile_height: Int32, pyramid: Bool, miniswhite: Bool, bitdepth: Int32, resunit: Enums::ForeignTiffResunit, xres: Float64, yres: Float64, bigtiff: Bool, properties: Bool, region_shrink: Enums::RegionShrink, level: Int32, lossless: Bool, depth: Enums::ForeignDzDepth, subifd: Bool, premultiply: Bool, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *compression* : Enums::ForeignTiffCompression - Compression for this file
    #
    # *q* : Int32 - Q factor
    #
    # *predictor* : Enums::ForeignTiffPredictor - Compression prediction
    #
    # *profile* : String - ICC profile to embed
    #
    # *tile* : Bool - Write a tiled tiff
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *pyramid* : Bool - Write a pyramidal tiff
    #
    # *miniswhite* : Bool - Use 0 for white in 1-bit images
    #
    # *bitdepth* : Int32 - Write as a 1, 2, 4 or 8 bit image
    #
    # *resunit* : Enums::ForeignTiffResunit - Resolution unit
    #
    # *xres* : Float64 - Horizontal resolution in pixels/mm
    #
    # *yres* : Float64 - Vertical resolution in pixels/mm
    #
    # *bigtiff* : Bool - Write a bigtiff image
    #
    # *properties* : Bool - Write a properties document to IMAGEDESCRIPTION
    #
    # *region_shrink* : Enums::RegionShrink - Method to shrink regions
    #
    # *level* : Int32 - ZSTD compression level
    #
    # *lossless* : Bool - Enable WEBP lossless mode
    #
    # *depth* : Enums::ForeignDzDepth - Pyramid depth
    #
    # *subifd* : Bool - Save pyr layers as sub-IFDs
    #
    # *premultiply* : Bool - Save with premultiplied alpha
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def tiffsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("tiffsave_buffer", options).as(Type).as_bytes
    end

    # Cache an image as a set of tiles
    #
    # ```
    # # out_ = in.tilecache({tile_width: Int32, tile_height: Int32, max_tiles: Int32, access: Enums::Access, threaded: Bool, persistent: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *tile_width* : Int32 - Tile width in pixels
    #
    # *tile_height* : Int32 - Tile height in pixels
    #
    # *max_tiles* : Int32 - Maximum number of tiles to cache
    #
    # *access* : Enums::Access - Expected access pattern
    #
    # *threaded* : Bool - Allow threaded access
    #
    # *persistent* : Bool - Keep cache between evaluations
    #
    #
    # **Returns**
    #
    # Output image
    #
    def tilecache(**kwargs)
      options = Optional.new(**kwargs)

      self.call("tilecache", options).as(Type).as_image
    end

    # Build a look-up table
    #
    # ```
    # # out_ = Vips::Image.tonelut({in_max: Int32, out_max: Int32, lb: Float64, lw: Float64, ps: Float64, pm: Float64, ph: Float64, s: Float64, m: Float64, h: Float64})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *in_max* : Int32 - Size of LUT to build
    #
    # *out_max* : Int32 - Maximum value in output LUT
    #
    # *lb* : Float64 - Lowest value in output
    #
    # *lw* : Float64 - Highest value in output
    #
    # *ps* : Float64 - Position of shadow
    #
    # *pm* : Float64 - Position of mid-tones
    #
    # *ph* : Float64 - Position of highlights
    #
    # *s* : Float64 - Adjust shadows by this much
    #
    # *m* : Float64 - Adjust mid-tones by this much
    #
    # *h* : Float64 - Adjust highlights by this much
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.tonelut(**kwargs)
      options = Optional.new(**kwargs)

      Operation.call("tonelut", options).as(Type).as_image
    end

    # Transpose3d an image
    #
    # ```
    # # out_ = in.transpose3d({page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *page_height* : Int32 - Height of each input page
    #
    #
    # **Returns**
    #
    # Output image
    #
    def transpose3d(**kwargs)
      options = Optional.new(**kwargs)

      self.call("transpose3d", options).as(Type).as_image
    end

    # Unpremultiply image alpha
    #
    # ```
    # # out_ = in.unpremultiply({max_alpha: Float64, alpha_band: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *max_alpha* : Float64 - Maximum value of alpha channel
    #
    # *alpha_band* : Int32 - Unpremultiply with this alpha
    #
    #
    # **Returns**
    #
    # Output image
    #
    def unpremultiply(**kwargs)
      options = Optional.new(**kwargs)

      self.call("unpremultiply", options).as(Type).as_image
    end

    # Load vips from file
    #
    # ```
    # # out_, flags = Vips::Image.vipsload(filename, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.vipsload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("vipsload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load vips from source
    #
    # ```
    # # out_, flags = Vips::Image.vipsload_source(source, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.vipsload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("vipsload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load vips from stream
    #
    # ```
    # # out_, flags = Vips::Image.vipsload_stream(stream, {memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.vipsload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      vipsload_source(source, **kwargs)
    end

    # Save image to file in vips format
    #
    # ```
    # in.vipssave(filename, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def vipssave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("vipssave", options, filename)
    end

    # Save image to target in vips format
    #
    # ```
    # in.vipssave_target(target, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def vipssave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("vipssave_target", options, target)
    end

    # Save image to stream in vips format
    #
    # ```
    # in.vipssave_stream(stream, {strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def vipssave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      vipssave_target(target, **kwargs)
    end

    # Load webp from file
    #
    # ```
    # # out_, flags = Vips::Image.webpload(filename, {page: Int32, n: Int32, scale: Float64, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *scale* : Float64 - Scale factor on load
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.webpload(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("webpload", options, filename).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load webp from buffer
    #
    # ```
    # # out_, flags = Vips::Image.webpload_buffer(buffer, {page: Int32, n: Int32, scale: Float64, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *buffer* : Bytes - Buffer to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *scale* : Float64 - Scale factor on load
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.webpload_buffer(buffer : Bytes, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("webpload_buffer", options, buffer).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load webp from source
    #
    # ```
    # # out_, flags = Vips::Image.webpload_source(source, {page: Int32, n: Int32, scale: Float64, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *source* : Source - Source to load from
    #
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *scale* : Float64 - Scale factor on load
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    #
    # **Returns**
    #
    # Output image
    #
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    #
    def self.webpload_source(source : Source, **kwargs)
      options = Optional.new(**kwargs)
      options["flags"] = true

      results = Operation.call("webpload_source", options, source).as(Array(Type))
      final_result = results.first.as(Type).as_image

      opts = results[1]?.try &.as_h

      flags = ((o = opts) && (val = o["flags"]?)) ? val.as_enum(Enums::ForeignFlags) : nil
      {final_result, flags}
    end

    # Load webp from stream
    #
    # ```
    # # out_, flags = Vips::Image.webpload_stream(stream, {page: Int32, n: Int32, scale: Float64, memory: Bool, access: Enums::Access, fail_on: Enums::FailOn})
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to load from
    # _Optionals_
    #
    # *page* : Int32 - Load this page from the file
    #
    # *n* : Int32 - Load this many pages
    #
    # *scale* : Float64 - Scale factor on load
    #
    # *memory* : Bool - Force open via memory
    #
    # *access* : Enums::Access - Required access pattern for this file
    #
    # *fail_on* : Enums::FailOn - Error level to fail on
    #
    # **Returns**
    #
    # *out* : Image - Output image
    # _Optionals_
    #
    # *flags* : Enums::ForeignFlags? - Flags for this file
    def self.webpload_stream(stream : IO, **kwargs)
      source = SourceStream.new_from_stream(stream)
      webpload_source(source, **kwargs)
    end

    # Save image to webp file
    #
    # ```
    # in.webpsave(filename, {q: Int32, lossless: Bool, preset: Enums::ForeignWebpPreset, smart_subsample: Bool, near_lossless: Bool, alpha_q: Int32, min_size: Bool, kmin: Int32, kmax: Int32, effort: Int32, profile: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *filename* : String - Filename to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - enable lossless compression
    #
    # *preset* : Enums::ForeignWebpPreset - Preset for lossy compression
    #
    # *smart_subsample* : Bool - Enable high quality chroma subsampling
    #
    # *near_lossless* : Bool - Enable preprocessing in lossless mode (uses Q)
    #
    # *alpha_q* : Int32 - Change alpha plane fidelity for lossy compression
    #
    # *min_size* : Bool - Optimise for minium size
    #
    # *kmin* : Int32 - Minimum number of frames between key frames
    #
    # *kmax* : Int32 - Maximum number of frames between key frames
    #
    # *effort* : Int32 - Level of CPU effort to reduce file size
    #
    # *profile* : String - ICC profile to embed
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def webpsave(filename : String, **kwargs)
      options = Optional.new(**kwargs)
      self.call("webpsave", options, filename)
    end

    # Save image to webp buffer
    #
    # ```
    # # buffer = in.webpsave_buffer({q: Int32, lossless: Bool, preset: Enums::ForeignWebpPreset, smart_subsample: Bool, near_lossless: Bool, alpha_q: Int32, min_size: Bool, kmin: Int32, kmax: Int32, effort: Int32, profile: String, strip: Bool, background: Array(Float64), page_height: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - enable lossless compression
    #
    # *preset* : Enums::ForeignWebpPreset - Preset for lossy compression
    #
    # *smart_subsample* : Bool - Enable high quality chroma subsampling
    #
    # *near_lossless* : Bool - Enable preprocessing in lossless mode (uses Q)
    #
    # *alpha_q* : Int32 - Change alpha plane fidelity for lossy compression
    #
    # *min_size* : Bool - Optimise for minium size
    #
    # *kmin* : Int32 - Minimum number of frames between key frames
    #
    # *kmax* : Int32 - Maximum number of frames between key frames
    #
    # *effort* : Int32 - Level of CPU effort to reduce file size
    #
    # *profile* : String - ICC profile to embed
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    #
    # **Returns**
    #
    # Buffer to save to
    #
    def webpsave_buffer(**kwargs)
      options = Optional.new(**kwargs)

      self.call("webpsave_buffer", options).as(Type).as_bytes
    end

    # Save image to webp target
    #
    # ```
    # in.webpsave_target(target, {q: Int32, lossless: Bool, preset: Enums::ForeignWebpPreset, smart_subsample: Bool, near_lossless: Bool, alpha_q: Int32, min_size: Bool, kmin: Int32, kmax: Int32, effort: Int32, profile: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *target* : Target - Target to save to
    #
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - enable lossless compression
    #
    # *preset* : Enums::ForeignWebpPreset - Preset for lossy compression
    #
    # *smart_subsample* : Bool - Enable high quality chroma subsampling
    #
    # *near_lossless* : Bool - Enable preprocessing in lossless mode (uses Q)
    #
    # *alpha_q* : Int32 - Change alpha plane fidelity for lossy compression
    #
    # *min_size* : Bool - Optimise for minium size
    #
    # *kmin* : Int32 - Minimum number of frames between key frames
    #
    # *kmax* : Int32 - Maximum number of frames between key frames
    #
    # *effort* : Int32 - Level of CPU effort to reduce file size
    #
    # *profile* : String - ICC profile to embed
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    #
    def webpsave_target(target : Target, **kwargs)
      options = Optional.new(**kwargs)
      self.call("webpsave_target", options, target)
    end

    # Save image to webp stream
    #
    # ```
    # in.webpsave_stream(stream, {q: Int32, lossless: Bool, preset: Enums::ForeignWebpPreset, smart_subsample: Bool, near_lossless: Bool, alpha_q: Int32, min_size: Bool, kmin: Int32, kmax: Int32, effort: Int32, profile: String, strip: Bool, background: Array(Float64), page_height: Int32})
    #
    # ```
    #
    # **Input Parameters**
    #
    # _Required_
    #
    # *stream* : IO - Stream to save to
    # _Optionals_
    #
    # *q* : Int32 - Q factor
    #
    # *lossless* : Bool - enable lossless compression
    #
    # *preset* : Enums::ForeignWebpPreset - Preset for lossy compression
    #
    # *smart_subsample* : Bool - Enable high quality chroma subsampling
    #
    # *near_lossless* : Bool - Enable preprocessing in lossless mode (uses Q)
    #
    # *alpha_q* : Int32 - Change alpha plane fidelity for lossy compression
    #
    # *min_size* : Bool - Optimise for minium size
    #
    # *kmin* : Int32 - Minimum number of frames between key frames
    #
    # *kmax* : Int32 - Maximum number of frames between key frames
    #
    # *effort* : Int32 - Level of CPU effort to reduce file size
    #
    # *profile* : String - ICC profile to embed
    #
    # *strip* : Bool - Strip all metadata from image
    #
    # *background* : Array(Float64) - Background value
    #
    # *page_height* : Int32 - Set page height for multipage save
    def webpsave_stream(stream : IO, **kwargs)
      target = TargetStream.new_from_stream(stream)
      webpsave_target(target, **kwargs)
    end

    # Make a worley noise image
    #
    # ```
    # # out_ = Vips::Image.worley(width, height, {cell_size: Int32, seed: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *cell_size* : Int32 - Size of Worley cells
    #
    # *seed* : Int32 - Random number seed
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.worley(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("worley", options, width, height).as(Type).as_image
    end

    # Wrap image origin
    #
    # ```
    # # out_ = in.wrap({x: Int32, y: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *x* : Int32 - Left edge of input in output
    #
    # *y* : Int32 - Top edge of input in output
    #
    #
    # **Returns**
    #
    # Output image
    #
    def wrap(**kwargs)
      options = Optional.new(**kwargs)

      self.call("wrap", options).as(Type).as_image
    end

    # Make an image where pixel values are coordinates
    #
    # ```
    # # out_ = Vips::Image.xyz(width, height, {csize: Int32, dsize: Int32, esize: Int32})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *csize* : Int32 - Size of third dimension
    #
    # *dsize* : Int32 - Size of fourth dimension
    #
    # *esize* : Int32 - Size of fifth dimension
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.xyz(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("xyz", options, width, height).as(Type).as_image
    end

    # Transform xyz to cmyk
    #
    # ```
    # # out_ = in.xyz2cmyk()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def xyz2cmyk
      self.call("xyz2cmyk").as(Type).as_image
    end

    # Transform xyz to lab
    #
    # ```
    # # out_ = in.xyz2lab({temp: Array(Float64)})
    # ```
    #
    #
    # Input Parameters
    #
    # _Optionals_
    #
    # *temp* : Array(Float64) - Colour temperature
    #
    #
    # **Returns**
    #
    # Output image
    #
    def xyz2lab(**kwargs)
      options = Optional.new(**kwargs)

      self.call("xyz2lab", options).as(Type).as_image
    end

    # Transform xyz to scrgb
    #
    # ```
    # # out_ = in.xyz2scrgb()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def xyz2scrgb
      self.call("xyz2scrgb").as(Type).as_image
    end

    # Transform xyz to yxy
    #
    # ```
    # # out_ = in.xyz2yxy()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def xyz2yxy
      self.call("xyz2yxy").as(Type).as_image
    end

    # Transform yxy to xyz
    #
    # ```
    # # out_ = in.yxy2xyz()
    # ```
    #
    #
    # **Returns**
    #
    # Output image
    #
    def yxy2xyz
      self.call("yxy2xyz").as(Type).as_image
    end

    # Make a zone plate
    #
    # ```
    # # out_ = Vips::Image.zone(width, height, {uchar: Bool})
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *width* : Int32 - Image width in pixels
    #
    # *height* : Int32 - Image height in pixels
    #
    # _Optionals_
    #
    # *uchar* : Bool - Output an unsigned char image
    #
    #
    # **Returns**
    #
    # Output image
    #
    def self.zone(width : Int32, height : Int32, **kwargs)
      options = Optional.new(**kwargs)

      Operation.call("zone", options, width, height).as(Type).as_image
    end

    # Zoom an image
    #
    # ```
    # # out_ = input.zoom(xfac, yfac)
    # ```
    #
    #
    # Input Parameters
    #
    # **Required**
    #
    # *xfac* : Int32 - Horizontal zoom factor
    #
    # *yfac* : Int32 - Vertical zoom factor
    #
    #
    # **Returns**
    #
    # Output image
    #
    def zoom(xfac : Int32, yfac : Int32)
      self.call("zoom", xfac, yfac).as(Type).as_image
    end

    # Image width in pixels
    def width : Int32
      get("width").as_i32
    end

    # Image height in pixels
    def height : Int32
      get("height").as_i32
    end

    # Number of bands in image
    def bands : Int32
      get("bands").as_i32
    end

    # Pixel format in image
    def format : Enums::BandFormat
      get("format").as_enum(Enums::BandFormat)
    end

    # Pixel coding
    def coding : Enums::Coding
      get("coding").as_enum(Enums::Coding)
    end

    # Pixel interpretation
    def interpretation : Enums::Interpretation
      get("interpretation").as_enum(Enums::Interpretation)
    end

    # Horizontal offset of origin
    def xoffset : Int32
      get("xoffset").as_i32
    end

    # Vertical offset of origin
    def yoffset : Int32
      get("yoffset").as_i32
    end

    # Horizontal resolution in pixels/mm
    def xres : Float64
      get("xres").as_f64
    end

    # Vertical resolution in pixels/mm
    def yres : Float64
      get("yres").as_f64
    end

    # Image filename
    def filename : String
      get("filename").as_s
    end
  end
end
